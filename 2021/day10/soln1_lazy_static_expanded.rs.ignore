#![feature(prelude_import)]
#![feature(array_zip)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
mod soln1 {
    use lazy_static::lazy_static;
    use phf::phf_map;
    #[path = "shared.rs"]
    mod shared {
        pub fn parse(input: &str) -> impl Iterator<Item = &str> {
            input.lines()
        }
    }
    enum Either<A, B> {
        Left(A),
        Right(B),
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    struct OPEN_TO_CLOSE {
        __private_field: (),
    }
    #[doc(hidden)]
    static OPEN_TO_CLOSE: OPEN_TO_CLOSE = OPEN_TO_CLOSE {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for OPEN_TO_CLOSE {
        type Target = phf::Map<char, char>;
        fn deref(&self) -> &phf::Map<char, char> {
            #[inline(always)]
            fn __static_ref_initialize() -> phf::Map<char, char> {
                {
                    #[allow(dead_code)]
                    enum ProcMacroHack {
                        Value = (
                            "\'(\' => \')\', \'[\' => \']\', \'{\' => \'}\', \'<\' => \'>\'",
                            0,
                        )
                            .1,
                    }
                    phf::Map {
                        key: 7485420634051515786u64,
                        disps: &[(1u32, 0u32)],
                        entries: &[('(', ')'), ('<', '>'), ('[', ']'), ('{', '}')],
                    }
                }
            }
            #[inline(always)]
            fn __stability() -> &'static phf::Map<char, char> {
                static LAZY: ::lazy_static::lazy::Lazy<phf::Map<char, char>> =
                    ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for OPEN_TO_CLOSE {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    struct CLOSE_TO_OPEN {
        __private_field: (),
    }
    #[doc(hidden)]
    static CLOSE_TO_OPEN: CLOSE_TO_OPEN = CLOSE_TO_OPEN {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for CLOSE_TO_OPEN {
        type Target = phf::Map<char, char>;
        fn deref(&self) -> &phf::Map<char, char> {
            #[inline(always)]
            fn __static_ref_initialize() -> phf::Map<char, char> {
                {
                    #[allow(dead_code)]
                    enum ProcMacroHack {
                        Value = (
                            "\')\' => \'(\', \']\' => \'[\', \'}\' => \'{\', \'>\' => \'<\'",
                            0,
                        )
                            .1,
                    }
                    phf::Map {
                        key: 12913932095322966823u64,
                        disps: &[(2u32, 0u32)],
                        entries: &[('>', '<'), (')', '('), (']', '['), ('}', '{')],
                    }
                }
            }
            #[inline(always)]
            fn __stability() -> &'static phf::Map<char, char> {
                static LAZY: ::lazy_static::lazy::Lazy<phf::Map<char, char>> =
                    ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for CLOSE_TO_OPEN {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    struct SCORES {
        __private_field: (),
    }
    #[doc(hidden)]
    static SCORES: SCORES = SCORES {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for SCORES {
        type Target = phf::Map<char, i32>;
        fn deref(&self) -> &phf::Map<char, i32> {
            #[inline(always)]
            fn __static_ref_initialize() -> phf::Map<char, i32> {
                {
                    #[allow(dead_code)]
                    enum ProcMacroHack {
                        Value = ("\')\' => 3, \']\' => 57, \'}\' => 1197, \'>\' => 25137, \'(\' => 1, \'[\' => 2, \'{\' => 3,\n\'<\' => 4" , 0) . 1 , }
                    phf::Map {
                        key: 12213676231523076107u64,
                        disps: &[(0u32, 0u32), (0u32, 0u32)],
                        entries: &[
                            ('}', 1197),
                            (')', 3),
                            ('>', 25137),
                            ('(', 1),
                            ('{', 3),
                            ('<', 4),
                            (']', 57),
                            ('[', 2),
                        ],
                    }
                }
            }
            #[inline(always)]
            fn __stability() -> &'static phf::Map<char, i32> {
                static LAZY: ::lazy_static::lazy::Lazy<phf::Map<char, i32>> =
                    ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for SCORES {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    ///
    /// * Using lazy_statics to avoid
    ///
    pub struct Soln1 {}
    impl Soln1 {
        fn first_illegal(line: &str) -> Either<usize, Vec<char>> {
            let mut stack: Vec<char> = Vec::new();
            let mut illegal_idx: Option<usize> = None;
            for (idx, char) in line.chars().enumerate() {
                if OPEN_TO_CLOSE.contains_key(&char) {
                    stack.push(char);
                } else {
                    let matching_open = CLOSE_TO_OPEN.get(&char).expect("illegal char");
                    if *stack.last().unwrap() == *matching_open {
                        stack.pop();
                    } else {
                        illegal_idx = Some(idx);
                        break;
                    }
                }
            }
            if let Some(bad_idx) = illegal_idx {
                Either::Left(bad_idx)
            } else {
                Either::Right(stack.clone())
            }
        }
        fn score_illegal(bracket: &char) -> i32 {
            *SCORES.get(bracket).expect("illegal bracket")
        }
        pub fn part1(input: &str) -> i32 {
            let lines = shared::parse(input);
            let mut total_score = 0;
            for line in lines {
                let line_score = match Self::first_illegal(line) {
                    Either::Left(bad_index) => {
                        let bad_char = line.chars().nth(bad_index).expect("illegal char");
                        let score = Self::score_illegal(&bad_char);
                        score
                    }
                    _ => 0,
                };
                total_score += line_score;
            }
            total_score
        }
        fn score_completion(completion: Vec<char>) -> i64 {
            let mut score = 0i64;
            for char in completion.iter().rev() {
                let br_score = *SCORES.get(char).expect("illegal char");
                score = (score * 5) + (i64::from(br_score));
            }
            score
        }
        pub fn part2(input: &str) -> i64 {
            let lines = shared::parse(input);
            let mut scores: Vec<i64> = ::alloc::vec::Vec::new();
            for line in lines {
                let case = Self::first_illegal(line);
                if let Either::Right(stack) = case {
                    let completion_score = Self::score_completion(stack);
                    scores.push(completion_score);
                }
            }
            scores.sort_unstable();
            scores[scores.len() / 2]
        }
    }
}
pub fn main() {
    {
        ::std::io::_print(::core::fmt::Arguments::new_v1(
            &["Hello Day 10!\n"],
            &match () {
                _args => [],
            },
        ));
    };
    let contents : & str = "{<[[<<<[[{[[<<()()>>[([]<>){{}{}}]]]<(<{{}<>}{{}{}}><{<>[]}[{}{}]>)({(())}<[(){}][(){}]>)>}]<<<(<<{}\n{[({({([({(((<[]()>[()<>]){[<>[]](<>[])})<<<[]()}>(<()()>)>)}[{((<{}[]>{<>()}){[<>{}]<<><>>})(({[]()}<<>()>)<\n(((([{{{<{<[[<()<>><<>{}>]]{<(<>())>}>{<[([]<>)<{}{}>][[<><>][<>[]]]>[{(<>{})[<>()]}<<()[]>[[]<\n<<[<([[{{{[({<<>()>}<<<>[]>([]())>){{{{}[]}<(){}>)}]{{[(()())[(){}]]<<[]{}>({}[])>}({<<><>>}<([]<>){()[]}>)}\n<[(({[({<<[[[{<>{}}(<><>))<(<>[])[{}[]]>]<[([][])[(){}]]>]([<[()()](<>[])>]<(<{}()>[{}<>])({<>[\n(<[[{[[[(<((<<{}{}><[]<>>><[{}<>][<>[]]>)<(<{}<>><{}{}>)[{()[]}<<>()>]>)>[(<{({}{})}[{()[]}{[]<>}]>){<(([]\n(([[({{{(<([({[]{}}){{[][]]}])>)[<([[[{}]{(){}}][([]())]]([{[][]}{<>()}](({}()){<>{}})))[{({\n{(<<([([(<<[{((){})([]<>)}]<{{{}{}}{{}[]}}<{(){}}{()[]})>><([<[]{}>([]<>)](<()<>>)){<([]<>\n{[<<[<{{((({<[[]{}]{{}}>{<{}<>>[<>[]]}})<{[(<><>><{}<>>][{[]{}}]}[[[[][]]<<>{}>]{[[]()][[]<>]}]>)[(\n({<(<([{<{<[(((){}){(){}})]>}[{{{{()()}<[]()>}{{<>()}<{}{}>}}[[{{}{}}[<><>]]{({}[]>[[]{}]}]}({{{()()\n{[[{([{<<{<(<<{}()>[()]>)<{{()()}}[<[][]>(<>{})]>>{[<{<>()){()<>}>{{()()}[<>()]}][[[{}[]]]<{{}[]}<()(\n{{<<<<<[[([{<[{}[]]{()<>}>{<<>()>{{}<>}}}<<{{}()}{()()}>{[()<>]({}[])]>]{[(<{}{}>)<({}[])>]<{({}<>)}{({}())\n({(<<{[<<{<(<[<>()][[][]]><[{}<>]({}[])>)[[[<>[]][[]()]]<{[]{}}[{}{}]>]>{[(<[]()>{<>{}})][<{{}}<{\n(<<<[[({<[[(<<[]{}>>[(()<>)[<>{}]])<{(<>[])}(<<>()>[[]{}])>]<[({[]()}{{}{}})<{{}()}<{}<>>>]>][[({<<>()>{[]()}\n{{{[<[([<(<{[([][])[{}[]]]{[()()]{{}()}}}><[<([][])(<>())><{()[]}({}<>)>]<<<(){}><<><>>>((()()){\n[(((([{({<(<(<[]<>>{()[]})><{(<><>){{}[]}}{(()<>)([][])}>)>})}][({{[[{<(<><>){{}()}>((<>()){<>[]\n([{<{<({(<[(<({}<>)><{[]}[{}[]]>)(<[[][]]{[]{}}>{{[]}((){})})]{(((()){{}()})(([][])({}{})))[(<()[]><(\n[([{{<{(<[{{((()())<[]{}>){{{}<>}<<><>>}}[<([]())>[(()[])<{}{}>]]}{[({(){}}{(){}])<<[]()>{{}()}>\n(<[<{{[<<({<<{<><>}><<()[]>[<><>]>>}{[(((){}){()<>}}<<[]()>{(){}}>]{{{{}[]}[{}<>]}[{{}{}}<(){}>]}}){{({\n<([([[<[({<<{{[][]}<{}[]>}<<()[]>[()<>]>>>})((<(<[[]]((){})>{([]()){<><>}})>)(<<<<[]<>>[[]()])>>([[\n[<<{<(<<{{[({<<>()><{}[]>})<{[<>()](<><>)}[{{}()}{[]()}]>]}}({<[{<()<>>}[<<>>]]((<[][]>{[][\n{{(<({[((<([({()<>})[{{}[]}(()<>))]{[{[]<>}][{()<>}]})([({<><>}{{}()})])>)({<(((()<>)(<><>)))>((\n[(<{({[<{<[<([{}()](<>{}))>]([([[]<>]<()<>>){<()>}]{{[[]()]{{}{}}}[{[]}{{}<>}]})>}<([<[<<>[]>]{<(){}>{\n[[[[<(<({<[[<{()}{{}[]}><[<><>]<()[]>>](<([]{})[{}]>)]>}<[{[[{(){}}]{(<><>)}][<<[][]>{(){}\n{(({({[{{((<[([]())((){})]>){[{(<>[])}<([]{})[[]<>]>]({<()<>>[[]<>]}[<()>{<>[]}])})({<([[][]]((){}))([<>{}])\n<(<(<<{[<<{<<[()[]][[]()]><([][])<{}()>>}}>[<<<<{}<>>>{[{}][{}{}]}>[<[()()]{{}[]}>[{[][]}([])]]>[[<<[][]>(\n<<{{({<<(([{{([][])(()<>)}}(<<[]{}>>)])([{[(()[])]}<{{<><>}<[]<>>}[<{}<>><[]<>)]>]{{<[{}[]]\n({[[[[(([[[{<({})([]())>{{<>{}}}}][[<<[]>[<>()]>]{[[[]<>][<>{}]]{[<>[]]}})][[<(<(){}>{()[]})><[[()[\n(((((([{{{(<<(<>{}){<>}><(()[])<()[]>>>{[<{}<>>(<>())}<{{}()}>})((([(){}]{<>})[{[]{}}{{}[]\n(([([(((<[(({[<>()]{[][]}})[{{[]()>[[]{}]}(<<>{}><{}<>>)]){[({[]}(<>[]))([()()][<>{}])]({({}\n[(<({{([[<(((<<>()>[[]<>])({{}()}<()<>>))[[{[]()}<()<>>][{()()}<{}[]>]])>({(<({}{})<()[]}>[{()\n{{{[([<{{{([<<<>{}>{()<>}>{<{}()><<><>>}]([{()}]))<{[<()()>{()[]}]{({}[])[<>()]}}>}}}({<(({({\n[([([<[<(<[{{{<>()}{()[]}}({()[]}[{}<>])}{[{<>}]([[][]]<(){}>)}]>[[{<[<>()][{}()]>(((){}>[<>[]])}{{{<>(\n{{[{{[[<{(<([[[][]]([]<>)])>)<{<<{<>()}[<>()]><((){})<<><>>>>([<<><>>(()<>)]([(){}}{[]<>}))}>}(({{{{[]}{\n[[[[({[<({{[[(<><>)]{<<>[]>([]{})}]<[{[]}{()()}]([<>()]([]<>>)>}})>{{<([{<{}{}>{()}}])({<[<>()](<><>)>\n{[({<[({[{[({[{}()][[]<>]}((()<>)<{}<>>))<[{{}}({}{})]>]{[<<<>[]>[[][]]>(({}[])(()[]))>{(([]{})({}[]))([\n[<<([{{(<<[<[[{}[]]](<[]{}>[<>{}])>[[<{}[]>(<>[])]{([][])[()[]]}]][[{{()[]}[<>{}]}(<<>{}>[[]\n<[(([{([([<{[[(){}]<<>{}>]}[[[()()]{{}<>}]]>[[{({}{})[()()]}([()()][<>[]])]{<[[]<>][[][]]>}]]{{<{[<>\n[<[[[[([[{[[<[{}{}]([]<>)>[({}[])<[]<>>]][<{()()}[<>[]]>([[]]<<><>>)]]}([<{{{}[]}}{(()<>>({}[\n<[<{[(<{({[<[[[][]]([][])]<([]){{}<>}>>[({<>{}}<[]>)]]([[([]{})[[]()]][[[]{}]({}{})]](<[{}<>\n({[<([(<[[<([[(){}]<<>{}>])({[[]{}]<()[]>}<<[]<>>{[][]}>)>{<[<[]()><{}[]>]([<>()]({}[]))><(\n({<<<{<({[[{[{<>{}}[<><>]]}{(({})[()()])<<()<>>([]{})>}]]]{<{{([[]<>](<>[]))[[{}()]({}())]}}>((<([{}<>])>{{<[\n[{([{[[{{<{<[{[]()}<[]{}>]>({<{}[]>{<>[]}})}[(({{}<>}<{}<>]){[[]{}]({}[])})]>}}]({([[([<()()>{[]\n<[{([([{[{<(([<>[]]{<>()})<{{}<>}>){([<><>])<(()[])<<>{}>>}><{{[{}<>]{<>}}[(())[()<>]]}<{[{}{}]{{}{}}}<{{}<>\n[{<<([{{(((<{<<>()>[{}()]}>{<<<>[]><[]()>>}){[(([][])([]()))<{{}[]}[[]()]>][[{{}<>}({}{})]{({}{})(<\n{({[((<([[[{{([])[()()]}({{}{}}))<(<[]<>>[()[]])>]<<([[]<>])<[<>()][[]<>]>>({[<><>]{{}[]}}({()[]\n{[(<(<{[({[(<<[]>{<>{}}>[{<><>}([]())])(<[[][]]<()<>>>[(()[])])]<{[{()[]}[<>{}]]}[{<(){}>(<>{})}<<<>()>>]\n(<{<[<({{{{([({}{})[[]{}]]({{}<>}<()[]}))}(<<{<>()}{()<>}>{[<>{}][()[]]}>{<<[][]>{<>()}><(<>{})<{}[]>>})}\n{(<<{[({<<[(<{{}{}}<[]<>>>((<>())([]<>)))]>><<({<{[]<>}([]<>)>{[()()]}}<<{{}<>}<()()>>(<()()\n<([([<(<[({[[({}()){()<>}](({}{})(<><>))][{({}<>)<{}{}>}{([]){(){}}}]})]>)<[[{<{{(()){<>[]}}({{}()}\n<<<([{[({{{((<{}()>{()()})[[<>()]])[[[{}()]<{}()>]{{[]<>}{{}())}]}<<{<<>><<><>>}[{{}[]}(<><>)\n<([<[<{[[[{[{[<><>][{}<>]}(<[]{}>)]}([{{<>()}<{}[]>}{([]<>)[(){}]}]<{((){})<[]()>}[<[]()><()[]>]>\n[([[[[[({{[(<[{}<>]<{}()>><[<><>]{<>()}>)]}<{(<(()<>)<{}{}>>{{()<>}(()()}})}>})(<[<([<<>[]>((){})]([[]<>]<()\n{(<[[{(((([[([{}()]<{}()))[({}{}){[]}]](<<<>[]>>([<>{}]))][(<({}{})<()[]>><<[]{}><{}[]>>)])(<([([][])[\n({(([{{<{{{<[<<>[]>{()<>}][([][]){()<>}]>([<()>(<><>)]<{<><>}<[]>>)}<{[[<>[]][<>{}]]<{<>()}{[][]\n{[([[[(([<{<{[[]<>]<<>()>}<<()()>([]{})>>[<<()[]>(<>())>[(()<>)]]}>]{{({{{{}[]}({})}<{{}<>}[[]()]>}((\n[<([[<[{{{[[[<<>{}>]{<()[]>{[]<>}}]{([[]{}]({}()))}]}}}(<{<[[({}{})<()()>]]({({}<>)[[]]}{[<><>]{<>{}}})>(<[\n<<(<<{{(({<[<<[]{}>{()()}}[[()[]]]]{[(<>{}){<>}]{[{}](<>)}}><{<(()())<[]<>>>[<(){}>(<>[])]\n{<(<[<[(((<{((()[])([]<>))([[]<>]({}[]))}><<([<>())<[]<>>)(<{}[]>({}<>))>[[([]())]({()()}{{}<>})\n[[((<[[[{{<{<{{}()}[{}()]>{{[]{}}[<><>]}}>}<{[<[(){}]<<><>>]([{}<>]<<><>>)]}(<<[{}<>]<<>{}>\n<[{{[[{<[{(({[(){}]({}{})})[([{}<>][()()])[<[][]><{}<>>]])}](<({(([]<>){()[]})[([]())((){})]}{{{<>{}}<[]()>}<\n<{((<([[{<<[(<{}()><{}[]>)]>[([{<>()}<()()>]<{()[]><()[]>>){<[{}[]]>[{[][]}(<><>)]}]>{{[{{{}<>}{<>}}[[(){}]<(\n{<[({(<{{[([{{[]{}}((){})}[[{}[]]<{}()>]]((<[]<>>)<([]()){{}[]}>))(<<{()[]}{[]})>[[(()())]{[()<>][<>(\n<<{[[[[{<({<[[{}()]]{{[]<>}{[]}}><{{{}()}({}{})}>}{([({}[])({}())](({}[])))[<{[]<>}[<>()]><<[]<>>(<>[])>]}\n[(([<<[{[{<({{()[]}<<><>>})[[([]())[[]{}])(<<>{}>)]>(<{{[][]}[{}()]}([{}{}][(){}])>((<<>[]>(()\n[({<<[[<{[<<({[]()}<()<>>)>]]{{<[[[]][{}<>]]>}{([[<>{}][{}{}]]<((){})(()[])>)}}}([{((<{}[]>)[<{}[]><{}()>])}\n{[[((<[{<<([{<<><>>([]{})}<(<><>)<<>()>>][{[[]{}]{()()}}<({}{})([][])>])><<{({<>{}}[<>()])((\n[[[<{{(<((([{<[]{}>({}<>)}[<<>()>]]<<(()[]){{}[]}>{(()<>){{}<>}}>){{{(()())[<><>]}[[[]<>]{<>[]}]}}))[\n(<({[({[[({{<{<>{}}<()[]>>[{(){}}<<>[]>]}[[<[][]><()<>>]({<>{}}{[]()})]}{(([[]<>][{}[]])(<[]<>>([\n{([<{[<({{{({[[][]][()()])[<<>()><[][]>])}<{{{[]()}[{}()]}{{<>()}{<>}}}((({}())<{}{}>){(<>{})[<>{}]})>}})(((\n([[[[[[{(((((<<>()>[[]<>])<{()()}[()<>]>){<[()[]]<<>[]>>(<<>{}}{{}[]})}))<<[([()()][[]()])[{()[]}([]())]][<([\n({{((((<{<[{[(<>{})][<()()>[[]()]]}]{({(<>())[[]()]}{<[][]><[][]>})}>}>{<<{{(({}())[<>])((()[])<[]<>>)}}[\n<(<[[[<<{([<<[[]<>]{<>[]}><{()()}([]<>)>>]{<{(<>())((){})}{[{}{}]<<>{}>}>})({([[{}{}]])[(<<>()>[\n{[(<{<[[{<{{(<()[]><<>{}>){[()<>]<{}<>>}}[[[<>{}][[]<>]]]}<[[({})<<>[]>]]{{<()<>><<>[]>}<{()[]}((){}\n({[{(<<{[<{({[()()]{{}}}<({}{}){()()}>)}<{(({}{})[<>[]]){([]())[[][]]}}{(<[]<>)[()])[[<>()]]}>>\n(({<<[<[<<<({<{}[]>({}{})}{<{}[]><{}[]>})>>(<<(<()()>{[]{}})({()<>}[()()])>[{[{}()][[]]}({<>()}}]>(\n<<(<(<[{([{<[[<>{}]<{}<>>]>{<(()[])(()())><{<>[]}{()()}>}}([{({}<>){<>{}}}{{<>[]}[{}{}]}]([<[]()>((){})\n{[{([({[[<<<{{[]{}}<[]{}>}[<()[]><[]<>>]>([{{}[]][[][]]]{{(){}}({}[])})>(<{[<>{}](()<>)}>{[<[]()>\n([[[<(<{[({<({()()}{<>()})((<>[])<[]<>>)>}<{<<{}()><<>>>}({{{}[]}}[(()[])[()<>]])>)<[<((()())[<>{}])(\n{<(((<[((((({<[]>[[]{}]}))[(<[[][]][{}{}]>){{[<>()][[]<>]}([()()](<><>))}])){(<[{[<>()][{}()]\n({([{<(((<{[<[{}[]]<<>>>({{}[]}[[]()])]([<(){}>])}{<[{<>[]}{[]<>}][<<><>){<>{}}]>[<((){})([]{})>[[{}{}][()\n<[{[<[{[({{<(({}<>}[[]()])>({{[][]}}<[(){}](()[])>)}})([[{{<<>()>([]{})}[<<>{}>[<><>]]}]])]\n{(<{([{[[({[(<[]{}>)({{}[]}{()()}))<{(()[])}[[()()]{{}[]}]>}<{<(()<>)>{{[]{}}({}())}}({{{}[]}{<\n[<<{<{<<(<([<(<>()){[]()}>[({}<>)({}<>)]][(([]{}){()[]})[{{}()}(()())]])>{([{{()[]}<<>[]>}<{<>[\n{{[[(([([({([([]<>)(()())][{<>()}{(){}}])})])]([{{[<{{{}<>}(<>())>{[()()]<<>[]>}>[{(()){{}[\n[({({({(({{(<[()()][{}<>]>[[{}()]{(){}}])<[<<>[]>][<{}>(<>{})]>}(((({}())({}{}))){{(()[])<[][\n<(<(<[([<[{[<(()<>)<()[]>><(<>())([][])>]{<[{}<>]{{}()}>{[[]{}](<>{})}}}<[<([]{})><{{}<>}([]())>]>]>\n<<<(<<[({{{<{({}<>)<()[]>}<[()<>]{(){}}>><{[[]()]<[]{}>}[({}{})<(){}>]>}(<[<<>[]>{()[]}]>)}[<{[<{}>[{}{\n{(<((<[{{[[[[<{}{}]<{}()>]][{({}{})<<>{}>}[<()[]>(()())]]]{([<[]()><[]{}>](<{}()>))({<<><>>(<>())}{\n{({{[[<[{<{{(<<>>)(<[]()>[()])}([({}<>)])}[[{[()<>][()[]]}]({<[]<>>{<>()}})]><<(<<{}()>{<>[]\n{{{[{[<<{[[{[{{}<>}<[][]>]{(()[])<<>()>}}[<{()()}[(){}]><<()[]>>]]{<((<>{})({}()))[<(){}>([][])]>{({{}[]}<\n<{{[<{({{{[<{{<>()}{{}()}}>]<{<[()[]](<><>)><[<>[]]{(){}}>}<([(){}]<{}{}>){(())}>>}[([{[[]<>][{}<>]}[{()}(\n[<<[{{(({({<{{{}{}}{<>[]}}({[][]}{<>[]})>[{[{}<>][<>[]]}[({}[])[[]<>]]]})}))<(<[[<(({}()))[<<>()>{(\n{<<([<{({[{{[({}[])<<>{}>]([()<>]<(){}>)}<([{}[]]({}{}))>}[<<<<>{}>[[][]]>{<<>[]><()>}>[<<<>><[][]>\n[({(<({[<[{{[<<>[]>[()[]]]<<<>[]>>}}<{([{}[]](<>{}))[{<>}{{}<>}]}(<<[][]>>[{[]<>}])>]>[(<(({<>[]}{<><>}))(<\n{<[[{{<<{(<(<([]<>)[[][]]>[([]{})[<>{}]])<[{<>()}{[]<>}]>>>[{(({()()}[<>[]]){({}())<[]<>>})}[(<{<>\n{[[{{{<[<[{<(({}{})[{}()])[(<><>)({}())]>}{[<{[]{}}[()[]]>]<{[()()]<[]()>}<[[][]]>>}]>{{({{{()[]}{{}(\n<{[<([{{[[<(<{<><>}[{}{}]><((){})>){[[()()][()[]]]{[[]<>]}}>]<<(<({}[])<{}[]>>{(<><>)<[]()>}){(<\n" ;
    let part1 = soln1::Soln1::part1(contents);
    {
        ::std::io::_print(::core::fmt::Arguments::new_v1(
            &["Part 1 = ", "\n"],
            &match (&part1,) {
                _args => [::core::fmt::ArgumentV1::new(
                    _args.0,
                    ::core::fmt::Debug::fmt,
                )],
            },
        ));
    };
    let part2 = soln1::Soln1::part2(contents);
    {
        ::std::io::_print(::core::fmt::Arguments::new_v1(
            &["Part 2 = ", "\n"],
            &match (&part2,) {
                _args => [::core::fmt::ArgumentV1::new(
                    _args.0,
                    ::core::fmt::Display::fmt,
                )],
            },
        ));
    };
}
