< /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/basic_ios.h
  1   | // Iostreams base classes -*- C++ -*-
  2   | 
  3   | // Copyright (C) 1997-2021 Free Software Foundation, Inc.
  4   | //
  5   | // This file is part of the GNU ISO C++ Library.  This library is free
  6   | // software; you can redistribute it and/or modify it under the
  7   | // terms of the GNU General Public License as published by the
  8   | // Free Software Foundation; either version 3, or (at your option)
  9   | // any later version.
 10   | 
 11   | // This library is distributed in the hope that it will be useful,
 12   | // but WITHOUT ANY WARRANTY; without even the implied warranty of
 13   | // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 14   | // GNU General Public License for more details.
 15   | 
 16   | // Under Section 7 of GPL version 3, you are granted additional
 17   | // permissions described in the GCC Runtime Library Exception, version
 18   | // 3.1, as published by the Free Software Foundation.
 19   | 
 20   | // You should have received a copy of the GNU General Public License and
 21   | // a copy of the GCC Runtime Library Exception along with this program;
 22   | // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 23   | // <http://www.gnu.org/licenses/>.
 24   | 
 25   | /** @file bits/basic_ios.h
 26   |  *  This is an internal header file, included by other library headers.
 27   |  *  Do not attempt to use it directly. @headername{ios}
 28   |  */
 29   | 
 30   | #ifndef _BASIC_IOS_H
 31   | #define _BASIC_IOS_H 1
 32   | 
 33   | #pragma GCC system_header
 34   | 
 35   | #include <bits/localefwd.h>
 36   | #include <bits/locale_classes.h>
 37   | #include <bits/locale_facets.h>
 38   | #include <bits/streambuf_iterator.h>
 39   | #include <bits/move.h>
 40   | 
 41   | namespace std _GLIBCXX_VISIBILITY(default)
 42   | {
 43   | _GLIBCXX_BEGIN_NAMESPACE_VERSION
 44   | 
 45   |   template<typename _Facet>
 46   |     inline const _Facet&
 47   |     __check_facet(const _Facet* __f)
 48   |     {
 49   |       if (!__f)
 50   | 	__throw_bad_cast();
 51   |       return *__f;
 52   |     }
 53   | 
 54   |   /**
 55   |    *  @brief Template class basic_ios, virtual base class for all
 56   |    *  stream classes. 
 57   |    *  @ingroup io
 58   |    *
 59   |    *  @tparam _CharT  Type of character stream.
 60   |    *  @tparam _Traits  Traits for character type, defaults to
 61   |    *                   char_traits<_CharT>.
 62   |    *
 63   |    *  Most of the member functions called dispatched on stream objects
 64   |    *  (e.g., @c std::cout.foo(bar);) are consolidated in this class.
 65   |   */
 66   |   template<typename _CharT, typename _Traits>
 67   |     class basic_ios : public ios_base
 68   |     {
 69   |     public:
 70   |       ///@{
 71   |       /**
 72   |        *  These are standard types.  They permit a standardized way of
 73   |        *  referring to names of (or names dependent on) the template
 74   |        *  parameters, which are specific to the implementation.
 75   |       */
 76   |       typedef _CharT                                 char_type;
 77   |       typedef typename _Traits::int_type             int_type;
 78   |       typedef typename _Traits::pos_type             pos_type;
 79   |       typedef typename _Traits::off_type             off_type;
 80   |       typedef _Traits                                traits_type;
 81   |       ///@}
 82   | 
 83   |       ///@{
 84   |       /**
 85   |        *  These are non-standard types.
 86   |       */
 87   |       typedef ctype<_CharT>                          __ctype_type;
 88   |       typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
 89   | 						     __num_put_type;
 90   |       typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
 91   | 						     __num_get_type;
 92   |       ///@}
 93   | 
 94   |       // Data members:
 95   |     protected:
 96   |       basic_ostream<_CharT, _Traits>*                _M_tie;
 97   |       mutable char_type                              _M_fill;
 98   |       mutable bool                                   _M_fill_init;
 99   |       basic_streambuf<_CharT, _Traits>*              _M_streambuf;
100   | 
101   |       // Cached use_facet<ctype>, which is based on the current locale info.
102   |       const __ctype_type*                            _M_ctype;
103   |       // For ostream.
104   |       const __num_put_type*                          _M_num_put;
105   |       // For istream.
106   |       const __num_get_type*                          _M_num_get;
107   | 
108   |     public:
109   |       ///@{
110   |       /**
111   |        *  @brief  The quick-and-easy status check.
112   |        *
113   |        *  This allows you to write constructs such as
114   |        *  <code>if (!a_stream) ...</code> and <code>while (a_stream) ...</code>
115   |       */
116   | #if __cplusplus >= 201103L
117   |       explicit operator bool() const
118   |       { return !this->fail(); }
119   | #else
120   |       operator void*() const
121   |       { return this->fail() ? 0 : const_cast<basic_ios*>(this); }
122   | #endif
123   | 
124   |       bool
125   |       operator!() const
126   |       { return this->fail(); }
127   |       ///@}
128   | 
129   |       /**
130   |        *  @brief  Returns the error state of the stream buffer.
131   |        *  @return  A bit pattern (well, isn't everything?)
132   |        *
133   |        *  See std::ios_base::iostate for the possible bit values.  Most
134   |        *  users will call one of the interpreting wrappers, e.g., good().
135   |       */
136   |       iostate
137   |       rdstate() const
138   |       { return _M_streambuf_state; }
139   | 
140   |       /**
141   |        *  @brief  [Re]sets the error state.
142   |        *  @param  __state  The new state flag(s) to set.
143   |        *
144   |        *  See std::ios_base::iostate for the possible bit values.  Most
145   |        *  users will not need to pass an argument.
146   |       */
147   |       void
148   |       clear(iostate __state = goodbit);
149   | 
150   |       /**
151   |        *  @brief  Sets additional flags in the error state.
152   |        *  @param  __state  The additional state flag(s) to set.
153   |        *
154   |        *  See std::ios_base::iostate for the possible bit values.
155   |       */
156   |       void
157   |       setstate(iostate __state)
158   |       { this->clear(this->rdstate() | __state); }
    I |                           ^
    I |                                     ^
159   | 
160   |       // Flip the internal state on for the proper state bits, then
161   |       // rethrows the propagated exception if bit also set in
162   |       // exceptions().
163   |       void
164   |       _M_setstate(iostate __state)
165   |       {
166   | 	// 27.6.1.2.1 Common requirements.
167   | 	// Turn this on without causing an ios::failure to be thrown.
168   | 	_M_streambuf_state |= __state;
169   | 	if (this->exceptions() & __state)
170   | 	  __throw_exception_again;
171   |       }
172   | 
173   |       /**
174   |        *  @brief  Fast error checking.
175   |        *  @return  True if no error flags are set.
176   |        *
177   |        *  A wrapper around rdstate.
178   |       */
179   |       bool
180   |       good() const
181   |       { return this->rdstate() == 0; }
182   | 
183   |       /**
184   |        *  @brief  Fast error checking.
185   |        *  @return  True if the eofbit is set.
186   |        *
187   |        *  Note that other iostate flags may also be set.
188   |       */
189   |       bool
190   |       eof() const
191   |       { return (this->rdstate() & eofbit) != 0; }
192   | 
193   |       /**
194   |        *  @brief  Fast error checking.
195   |        *  @return  True if either the badbit or the failbit is set.
196   |        *
197   |        *  Checking the badbit in fail() is historical practice.
198   |        *  Note that other iostate flags may also be set.
199   |       */
200   |       bool
201   |       fail() const
202   |       { return (this->rdstate() & (badbit | failbit)) != 0; }
203   | 
204   |       /**
205   |        *  @brief  Fast error checking.
206   |        *  @return  True if the badbit is set.
207   |        *
208   |        *  Note that other iostate flags may also be set.
209   |       */
210   |       bool
211   |       bad() const
212   |       { return (this->rdstate() & badbit) != 0; }
213   | 
214   |       /**
215   |        *  @brief  Throwing exceptions on errors.
216   |        *  @return  The current exceptions mask.
217   |        *
218   |        *  This changes nothing in the stream.  See the one-argument version
219   |        *  of exceptions(iostate) for the meaning of the return value.
220   |       */
221   |       iostate
222   |       exceptions() const
223   |       { return _M_exception; }
224   | 
225   |       /**
226   |        *  @brief  Throwing exceptions on errors.
227   |        *  @param  __except  The new exceptions mask.
228   |        *
229   |        *  By default, error flags are set silently.  You can set an
230   |        *  exceptions mask for each stream; if a bit in the mask becomes set
231   |        *  in the error flags, then an exception of type
232   |        *  std::ios_base::failure is thrown.
233   |        *
234   |        *  If the error flag is already set when the exceptions mask is
235   |        *  added, the exception is immediately thrown.  Try running the
236   |        *  following under GCC 3.1 or later:
237   |        *  @code
238   |        *  #include <iostream>
239   |        *  #include <fstream>
240   |        *  #include <exception>
241   |        *
242   |        *  int main()
243   |        *  {
244   |        *      std::set_terminate (__gnu_cxx::__verbose_terminate_handler);
245   |        *
246   |        *      std::ifstream f ("/etc/motd");
247   |        *
248   |        *      std::cerr << "Setting badbit\n";
249   |        *      f.setstate (std::ios_base::badbit);
250   |        *
251   |        *      std::cerr << "Setting exception mask\n";
252   |        *      f.exceptions (std::ios_base::badbit);
253   |        *  }
254   |        *  @endcode
255   |       */
256   |       void
257   |       exceptions(iostate __except)
258   |       {
259   |         _M_exception = __except;
260   |         this->clear(_M_streambuf_state);
261   |       }
262   | 
263   |       // Constructor/destructor:
264   |       /**
265   |        *  @brief  Constructor performs initialization.
266   |        *
267   |        *  The parameter is passed by derived streams.
268   |       */
269   |       explicit
270   |       basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
271   |       : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
272   | 	_M_ctype(0), _M_num_put(0), _M_num_get(0)
273   |       { this->init(__sb); }
274   | 
275   |       /**
276   |        *  @brief  Empty.
277   |        *
278   |        *  The destructor does nothing.  More specifically, it does not
279   |        *  destroy the streambuf held by rdbuf().
280   |       */
281   |       virtual
282   |       ~basic_ios() { }
283   | 
284   |       // Members:
285   |       /**
286   |        *  @brief  Fetches the current @e tied stream.
287   |        *  @return  A pointer to the tied stream, or NULL if the stream is
288   |        *           not tied.
289   |        *
290   |        *  A stream may be @e tied (or synchronized) to a second output
291   |        *  stream.  When this stream performs any I/O, the tied stream is
292   |        *  first flushed.  For example, @c std::cin is tied to @c std::cout.
293   |       */
294   |       basic_ostream<_CharT, _Traits>*
295   |       tie() const
296   |       { return _M_tie; }
297   | 
298   |       /**
299   |        *  @brief  Ties this stream to an output stream.
300   |        *  @param  __tiestr  The output stream.
301   |        *  @return  The previously tied output stream, or NULL if the stream
302   |        *           was not tied.
303   |        *
304   |        *  This sets up a new tie; see tie() for more.
305   |       */
306   |       basic_ostream<_CharT, _Traits>*
307   |       tie(basic_ostream<_CharT, _Traits>* __tiestr)
308   |       {
309   |         basic_ostream<_CharT, _Traits>* __old = _M_tie;
310   |         _M_tie = __tiestr;
311   |         return __old;
312   |       }
313   | 
314   |       /**
315   |        *  @brief  Accessing the underlying buffer.
316   |        *  @return  The current stream buffer.
317   |        *
318   |        *  This does not change the state of the stream.
319   |       */
320   |       basic_streambuf<_CharT, _Traits>*
321   |       rdbuf() const
322   |       { return _M_streambuf; }
323   | 
324   |       /**
325   |        *  @brief  Changing the underlying buffer.
326   |        *  @param  __sb  The new stream buffer.
327   |        *  @return  The previous stream buffer.
328   |        *
329   |        *  Associates a new buffer with the current stream, and clears the
330   |        *  error state.
331   |        *
332   |        *  Due to historical accidents which the LWG refuses to correct, the
333   |        *  I/O library suffers from a design error:  this function is hidden
334   |        *  in derived classes by overrides of the zero-argument @c rdbuf(),
335   |        *  which is non-virtual for hysterical raisins.  As a result, you
336   |        *  must use explicit qualifications to access this function via any
337   |        *  derived class.  For example:
338   |        *
339   |        *  @code
340   |        *  std::fstream     foo;         // or some other derived type
341   |        *  std::streambuf*  p = .....;
342   |        *
343   |        *  foo.ios::rdbuf(p);            // ios == basic_ios<char>
344   |        *  @endcode
345   |       */
346   |       basic_streambuf<_CharT, _Traits>*
347   |       rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
348   | 
349   |       /**
350   |        *  @brief  Copies fields of __rhs into this.
351   |        *  @param  __rhs  The source values for the copies.
352   |        *  @return  Reference to this object.
353   |        *
354   |        *  All fields of __rhs are copied into this object except that rdbuf()
355   |        *  and rdstate() remain unchanged.  All values in the pword and iword
356   |        *  arrays are copied.  Before copying, each callback is invoked with
357   |        *  erase_event.  After copying, each (new) callback is invoked with
358   |        *  copyfmt_event.  The final step is to copy exceptions().
359   |       */
360   |       basic_ios&
361   |       copyfmt(const basic_ios& __rhs);
362   | 
363   |       /**
364   |        *  @brief  Retrieves the @a empty character.
365   |        *  @return  The current fill character.
366   |        *
367   |        *  It defaults to a space (' ') in the current locale.
368   |       */
369   |       char_type
370   |       fill() const
371   |       {
372   | 	if (!_M_fill_init)
373   | 	  {
374   | 	    _M_fill = this->widen(' ');
375   | 	    _M_fill_init = true;
376   | 	  }
377   | 	return _M_fill;
378   |       }
379   | 
380   |       /**
381   |        *  @brief  Sets a new @a empty character.
382   |        *  @param  __ch  The new character.
383   |        *  @return  The previous fill character.
384   |        *
385   |        *  The fill character is used to fill out space when P+ characters
386   |        *  have been requested (e.g., via setw), Q characters are actually
387   |        *  used, and Q<P.  It defaults to a space (' ') in the current locale.
388   |       */
389   |       char_type
390   |       fill(char_type __ch)
391   |       {
392   | 	char_type __old = this->fill();
393   | 	_M_fill = __ch;
394   | 	return __old;
395   |       }
396   | 
397   |       // Locales:
398   |       /**
399   |        *  @brief  Moves to a new locale.
400   |        *  @param  __loc  The new locale.
401   |        *  @return  The previous locale.
402   |        *
403   |        *  Calls @c ios_base::imbue(loc), and if a stream buffer is associated
404   |        *  with this stream, calls that buffer's @c pubimbue(loc).
405   |        *
406   |        *  Additional l10n notes are at
407   |        *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
408   |       */
409   |       locale
410   |       imbue(const locale& __loc);
411   | 
412   |       /**
413   |        *  @brief  Squeezes characters.
414   |        *  @param  __c  The character to narrow.
415   |        *  @param  __dfault  The character to narrow.
416   |        *  @return  The narrowed character.
417   |        *
418   |        *  Maps a character of @c char_type to a character of @c char,
419   |        *  if possible.
420   |        *
421   |        *  Returns the result of
422   |        *  @code
423   |        *    std::use_facet<ctype<char_type> >(getloc()).narrow(c,dfault)
424   |        *  @endcode
425   |        *
426   |        *  Additional l10n notes are at
427   |        *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
428   |       */
429   |       char
430   |       narrow(char_type __c, char __dfault) const
431   |       { return __check_facet(_M_ctype).narrow(__c, __dfault); }
432   | 
433   |       /**
434   |        *  @brief  Widens characters.
435   |        *  @param  __c  The character to widen.
436   |        *  @return  The widened character.
437   |        *
438   |        *  Maps a character of @c char to a character of @c char_type.
439   |        *
440   |        *  Returns the result of
441   |        *  @code
442   |        *    std::use_facet<ctype<char_type> >(getloc()).widen(c)
443   |        *  @endcode
444   |        *
445   |        *  Additional l10n notes are at
446   |        *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
447   |       */
448   |       char_type
449   |       widen(char __c) const
450   |       { return __check_facet(_M_ctype).widen(__c); }
    I |                ^
    I |                                        ^
451   | 
452   |     protected:
453   |       // 27.4.5.1  basic_ios constructors
454   |       /**
455   |        *  @brief  Empty.
456   |        *
457   |        *  The default constructor does nothing and is not normally
458   |        *  accessible to users.
459   |       */
460   |       basic_ios()
461   |       : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false), 
462   | 	_M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
463   |       { }
464   | 
465   |       /**
466   |        *  @brief  All setup is performed here.
467   |        *
468   |        *  This is called from the public constructor.  It is not virtual and
469   |        *  cannot be redefined.
470   |       */
471   |       void
472   |       init(basic_streambuf<_CharT, _Traits>* __sb);
473   | 
474   | #if __cplusplus >= 201103L
475   |       basic_ios(const basic_ios&) = delete;
476   |       basic_ios& operator=(const basic_ios&) = delete;
477   | 
478   |       void
479   |       move(basic_ios& __rhs)
480   |       {
481   | 	ios_base::_M_move(__rhs);
482   | 	_M_cache_locale(_M_ios_locale);
483   | 	this->tie(__rhs.tie(nullptr));
484   | 	_M_fill = __rhs._M_fill;
485   | 	_M_fill_init = __rhs._M_fill_init;
486   | 	_M_streambuf = nullptr;
487   |       }
488   | 
489   |       void
490   |       move(basic_ios&& __rhs)
491   |       { this->move(__rhs); }
492   | 
493   |       void
494   |       swap(basic_ios& __rhs) noexcept
495   |       {
496   | 	ios_base::_M_swap(__rhs);
497   | 	_M_cache_locale(_M_ios_locale);
498   | 	__rhs._M_cache_locale(__rhs._M_ios_locale);
499   | 	std::swap(_M_tie, __rhs._M_tie);
500   | 	std::swap(_M_fill, __rhs._M_fill);
501   | 	std::swap(_M_fill_init, __rhs._M_fill_init);
502   |       }
503   | 
504   |       void
505   |       set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
506   |       { _M_streambuf = __sb; }
507   | #endif
508   | 
509   |       void
510   |       _M_cache_locale(const locale& __loc);
511   |     };
512   | 
513   | _GLIBCXX_END_NAMESPACE_VERSION
514   | } // namespace
515   | 
516   | #include <bits/basic_ios.tcc>
517   | 
518   | #endif /* _BASIC_IOS_H */

< /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/char_traits.h
  1  | // Character Traits for use by standard string and iostream -*- C++ -*-
  2  | 
  3  | // Copyright (C) 1997-2021 Free Software Foundation, Inc.
  4  | //
  5  | // This file is part of the GNU ISO C++ Library.  This library is free
  6  | // software; you can redistribute it and/or modify it under the
  7  | // terms of the GNU General Public License as published by the
  8  | // Free Software Foundation; either version 3, or (at your option)
  9  | // any later version.
 10  | 
 11  | // This library is distributed in the hope that it will be useful,
 12  | // but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  | // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 14  | // GNU General Public License for more details.
 15  | 
 16  | // Under Section 7 of GPL version 3, you are granted additional
 17  | // permissions described in the GCC Runtime Library Exception, version
 18  | // 3.1, as published by the Free Software Foundation.
 19  | 
 20  | // You should have received a copy of the GNU General Public License and
 21  | // a copy of the GCC Runtime Library Exception along with this program;
 22  | // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 23  | // <http://www.gnu.org/licenses/>.
 24  | 
 25  | /** @file bits/char_traits.h
 26  |  *  This is an internal header file, included by other library headers.
 27  |  *  Do not attempt to use it directly. @headername{string}
 28  |  */
 29  | 
 30  | //
 31  | // ISO C++ 14882: 21  Strings library
 32  | //
 33  | 
 34  | #ifndef _CHAR_TRAITS_H
 35  | #define _CHAR_TRAITS_H 1
 36  | 
 37  | #pragma GCC system_header
 38  | 
 39  | #include <bits/stl_algobase.h>  // std::copy, std::fill_n
 40  | #include <bits/postypes.h>      // For streampos
 41  | #include <cwchar>               // For WEOF, wmemmove, wmemset, etc.
 42  | #if __cplusplus > 201703L
 43  | # include <compare>
 44  | #endif
 45  | 
 46  | #ifndef _GLIBCXX_ALWAYS_INLINE
 47  | # define _GLIBCXX_ALWAYS_INLINE inline __attribute__((__always_inline__))
 48  | #endif
 49  | 
 50  | namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
 51  | {
 52  | _GLIBCXX_BEGIN_NAMESPACE_VERSION
 53  | 
 54  |   /**
 55  |    *  @brief  Mapping from character type to associated types.
 56  |    *
 57  |    *  @note This is an implementation class for the generic version
 58  |    *  of char_traits.  It defines int_type, off_type, pos_type, and
 59  |    *  state_type.  By default these are unsigned long, streamoff,
 60  |    *  streampos, and mbstate_t.  Users who need a different set of
 61  |    *  types, but who don't need to change the definitions of any function
 62  |    *  defined in char_traits, can specialize __gnu_cxx::_Char_types
 63  |    *  while leaving __gnu_cxx::char_traits alone. */
 64  |   template<typename _CharT>
 65  |     struct _Char_types
 66  |     {
 67  |       typedef unsigned long   int_type;
 68  |       typedef std::streampos  pos_type;
 69  |       typedef std::streamoff  off_type;
 70  |       typedef std::mbstate_t  state_type;
 71  |     };
 72  | 
 73  | 
 74  |   /**
 75  |    *  @brief  Base class used to implement std::char_traits.
 76  |    *
 77  |    *  @note For any given actual character type, this definition is
 78  |    *  probably wrong.  (Most of the member functions are likely to be
 79  |    *  right, but the int_type and state_type typedefs, and the eof()
 80  |    *  member function, are likely to be wrong.)  The reason this class
 81  |    *  exists is so users can specialize it.  Classes in namespace std
 82  |    *  may not be specialized for fundamental types, but classes in
 83  |    *  namespace __gnu_cxx may be.
 84  |    *
 85  |    *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/strings.html#strings.string.character_types
 86  |    *  for advice on how to make use of this class for @a unusual character
 87  |    *  types. Also, check out include/ext/pod_char_traits.h.  
 88  |    */
 89  |   template<typename _CharT>
 90  |     struct char_traits
 91  |     {
 92  |       typedef _CharT                                    char_type;
 93  |       typedef typename _Char_types<_CharT>::int_type    int_type;
 94  |       typedef typename _Char_types<_CharT>::pos_type    pos_type;
 95  |       typedef typename _Char_types<_CharT>::off_type    off_type;
 96  |       typedef typename _Char_types<_CharT>::state_type  state_type;
 97  | #if __cpp_lib_three_way_comparison
 98  |       using comparison_category = std::strong_ordering;
 99  | #endif
100  | 
101  |       static _GLIBCXX14_CONSTEXPR void
102  |       assign(char_type& __c1, const char_type& __c2)
103  |       { __c1 = __c2; }
104  | 
105  |       static _GLIBCXX_CONSTEXPR bool
106  |       eq(const char_type& __c1, const char_type& __c2)
107  |       { return __c1 == __c2; }
108  | 
109  |       static _GLIBCXX_CONSTEXPR bool
110  |       lt(const char_type& __c1, const char_type& __c2)
111  |       { return __c1 < __c2; }
112  | 
113  |       static _GLIBCXX14_CONSTEXPR int
114  |       compare(const char_type* __s1, const char_type* __s2, std::size_t __n);
115  | 
116  |       static _GLIBCXX14_CONSTEXPR std::size_t
117  |       length(const char_type* __s);
118  | 
119  |       static _GLIBCXX14_CONSTEXPR const char_type*
120  |       find(const char_type* __s, std::size_t __n, const char_type& __a);
121  | 
122  |       static _GLIBCXX20_CONSTEXPR char_type*
123  |       move(char_type* __s1, const char_type* __s2, std::size_t __n);
124  | 
125  |       static _GLIBCXX20_CONSTEXPR char_type*
126  |       copy(char_type* __s1, const char_type* __s2, std::size_t __n);
127  | 
128  |       static _GLIBCXX20_CONSTEXPR char_type*
129  |       assign(char_type* __s, std::size_t __n, char_type __a);
130  | 
131  |       static _GLIBCXX_CONSTEXPR char_type
132  |       to_char_type(const int_type& __c)
133  |       { return static_cast<char_type>(__c); }
134  | 
135  |       static _GLIBCXX_CONSTEXPR int_type
136  |       to_int_type(const char_type& __c)
137  |       { return static_cast<int_type>(__c); }
138  | 
139  |       static _GLIBCXX_CONSTEXPR bool
140  |       eq_int_type(const int_type& __c1, const int_type& __c2)
141  |       { return __c1 == __c2; }
142  | 
143  |       static _GLIBCXX_CONSTEXPR int_type
144  |       eof()
145  |       { return static_cast<int_type>(_GLIBCXX_STDIO_EOF); }
146  | 
147  |       static _GLIBCXX_CONSTEXPR int_type
148  |       not_eof(const int_type& __c)
149  |       { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
150  |     };
151  | 
152  |   template<typename _CharT>
153  |     _GLIBCXX14_CONSTEXPR int
154  |     char_traits<_CharT>::
155  |     compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
156  |     {
157  |       for (std::size_t __i = 0; __i < __n; ++__i)
158  | 	if (lt(__s1[__i], __s2[__i]))
159  | 	  return -1;
160  | 	else if (lt(__s2[__i], __s1[__i]))
161  | 	  return 1;
162  |       return 0;
163  |     }
164  | 
165  |   template<typename _CharT>
166  |     _GLIBCXX14_CONSTEXPR std::size_t
167  |     char_traits<_CharT>::
168  |     length(const char_type* __p)
169  |     {
170  |       std::size_t __i = 0;
171  |       while (!eq(__p[__i], char_type()))
172  |         ++__i;
173  |       return __i;
174  |     }
175  | 
176  |   template<typename _CharT>
177  |     _GLIBCXX14_CONSTEXPR const typename char_traits<_CharT>::char_type*
178  |     char_traits<_CharT>::
179  |     find(const char_type* __s, std::size_t __n, const char_type& __a)
180  |     {
181  |       for (std::size_t __i = 0; __i < __n; ++__i)
182  |         if (eq(__s[__i], __a))
183  |           return __s + __i;
184  |       return 0;
185  |     }
186  | 
187  |   template<typename _CharT>
188  |     _GLIBCXX20_CONSTEXPR
189  |     typename char_traits<_CharT>::char_type*
190  |     char_traits<_CharT>::
191  |     move(char_type* __s1, const char_type* __s2, std::size_t __n)
192  |     {
193  |       if (__n == 0)
194  | 	return __s1;
195  | #ifdef __cpp_lib_is_constant_evaluated
196  |       if (std::is_constant_evaluated())
197  | 	{
198  | 	  if (__s1 > __s2 && __s1 < __s2 + __n)
199  | 	    std::copy_backward(__s2, __s2 + __n, __s1 + __n);
200  | 	  else
201  | 	    std::copy(__s2, __s2 + __n, __s1);
202  | 	  return __s1;
203  | 	}
204  | #endif
205  |       return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
206  | 						    __n * sizeof(char_type)));
207  |     }
208  | 
209  |   template<typename _CharT>
210  |     _GLIBCXX20_CONSTEXPR
211  |     typename char_traits<_CharT>::char_type*
212  |     char_traits<_CharT>::
213  |     copy(char_type* __s1, const char_type* __s2, std::size_t __n)
214  |     {
215  |       // NB: Inline std::copy so no recursive dependencies.
216  |       std::copy(__s2, __s2 + __n, __s1);
217  |       return __s1;
218  |     }
219  | 
220  |   template<typename _CharT>
221  |     _GLIBCXX20_CONSTEXPR
222  |     typename char_traits<_CharT>::char_type*
223  |     char_traits<_CharT>::
224  |     assign(char_type* __s, std::size_t __n, char_type __a)
225  |     {
226  |       // NB: Inline std::fill_n so no recursive dependencies.
227  |       std::fill_n(__s, __n, __a);
228  |       return __s;
229  |     }
230  | 
231  | _GLIBCXX_END_NAMESPACE_VERSION
232  | } // namespace
233  | 
234  | namespace std _GLIBCXX_VISIBILITY(default)
235  | {
236  | _GLIBCXX_BEGIN_NAMESPACE_VERSION
237  | 
238  | #if __cplusplus >= 201703L
239  | 
240  | #ifdef __cpp_lib_is_constant_evaluated
241  | // Unofficial macro indicating P1032R1 support in C++20
242  | # define __cpp_lib_constexpr_char_traits 201811L
243  | #else
244  | // Unofficial macro indicating P0426R1 support in C++17
245  | # define __cpp_lib_constexpr_char_traits 201611L
246  | #endif
247  | 
248  |   /**
249  |    *  @brief Determine whether the characters of a NULL-terminated
250  |    *  string are known at compile time.
251  |    *  @param  __s  The string.
252  |    *
253  |    *  Assumes that _CharT is a built-in character type.
254  |    */
255  |   template<typename _CharT>
256  |     _GLIBCXX_ALWAYS_INLINE constexpr bool
257  |     __constant_string_p(const _CharT* __s)
258  |     {
259  | #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
260  |       (void) __s;
261  |       // In constexpr contexts all strings should be constant.
262  |       return __builtin_is_constant_evaluated();
263  | #else
264  |       while (__builtin_constant_p(*__s) && *__s)
265  | 	__s++;
266  |       return __builtin_constant_p(*__s);
267  | #endif
268  |     }
269  | 
270  |   /**
271  |    *  @brief Determine whether the characters of a character array are
272  |    *  known at compile time.
273  |    *  @param  __a  The character array.
274  |    *  @param  __n  Number of characters.
275  |    *
276  |    *  Assumes that _CharT is a built-in character type.
277  |    */
278  |   template<typename _CharT>
279  |     _GLIBCXX_ALWAYS_INLINE constexpr bool
280  |     __constant_char_array_p(const _CharT* __a, size_t __n)
281  |     {
282  | #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
283  |       (void) __a;
284  |       (void) __n;
285  |       // In constexpr contexts all character arrays should be constant.
286  |       return __builtin_is_constant_evaluated();
287  | #else
288  |       size_t __i = 0;
289  |       while (__i < __n && __builtin_constant_p(__a[__i]))
290  | 	__i++;
291  |       return __i == __n;
292  | #endif
293  |     }
294  | #endif
295  | 
296  |   // 21.1
297  |   /**
298  |    *  @brief  Basis for explicit traits specializations.
299  |    *
300  |    *  @note  For any given actual character type, this definition is
301  |    *  probably wrong.  Since this is just a thin wrapper around
302  |    *  __gnu_cxx::char_traits, it is possible to achieve a more
303  |    *  appropriate definition by specializing __gnu_cxx::char_traits.
304  |    *
305  |    *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/strings.html#strings.string.character_types
306  |    *  for advice on how to make use of this class for @a unusual character
307  |    *  types. Also, check out include/ext/pod_char_traits.h.
308  |   */
309  |   template<class _CharT>
310  |     struct char_traits : public __gnu_cxx::char_traits<_CharT>
311  |     { };
312  | 
313  | 
314  |   /// 21.1.3.1  char_traits specializations
315  |   template<>
316  |     struct char_traits<char>
317  |     {
318  |       typedef char              char_type;
319  |       typedef int               int_type;
320  |       typedef streampos         pos_type;
321  |       typedef streamoff         off_type;
322  |       typedef mbstate_t         state_type;
323  | #if __cpp_lib_three_way_comparison
324  |       using comparison_category = strong_ordering;
325  | #endif
326  | 
327  |       static _GLIBCXX17_CONSTEXPR void
328  |       assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
329  |       { __c1 = __c2; }
330  | 
331  |       static _GLIBCXX_CONSTEXPR bool
332  |       eq(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
333  |       { return __c1 == __c2; }
334  | 
335  |       static _GLIBCXX_CONSTEXPR bool
336  |       lt(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
337  |       {
338  | 	// LWG 467.
339  | 	return (static_cast<unsigned char>(__c1)
340  | 		< static_cast<unsigned char>(__c2));
341  |       }
342  | 
343  |       static _GLIBCXX17_CONSTEXPR int
344  |       compare(const char_type* __s1, const char_type* __s2, size_t __n)
345  |       {
346  | 	if (__n == 0)
347  | 	  return 0;
348  | #if __cplusplus >= 201703L
349  | 	if (__builtin_constant_p(__n)
350  | 	    && __constant_char_array_p(__s1, __n)
351  | 	    && __constant_char_array_p(__s2, __n))
352  | 	  {
353  | 	    for (size_t __i = 0; __i < __n; ++__i)
354  | 	      if (lt(__s1[__i], __s2[__i]))
355  | 		return -1;
356  | 	      else if (lt(__s2[__i], __s1[__i]))
357  | 		return 1;
358  | 	    return 0;
359  | 	  }
360  | #endif
361  | 	return __builtin_memcmp(__s1, __s2, __n);
362  |       }
363  | 
364  |       static _GLIBCXX17_CONSTEXPR size_t
365  |       length(const char_type* __s)
366  |       {
367  | #if __cplusplus >= 201703L
368  | 	if (__constant_string_p(__s))
369  | 	  return __gnu_cxx::char_traits<char_type>::length(__s);
370  | #endif
371  | 	return __builtin_strlen(__s);
372  |       }
373  | 
374  |       static _GLIBCXX17_CONSTEXPR const char_type*
375  |       find(const char_type* __s, size_t __n, const char_type& __a)
376  |       {
377  | 	if (__n == 0)
378  | 	  return 0;
379  | #if __cplusplus >= 201703L
380  | 	if (__builtin_constant_p(__n)
381  | 	    && __builtin_constant_p(__a)
382  | 	    && __constant_char_array_p(__s, __n))
383  | 	  return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
384  | #endif
385  | 	return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
386  |       }
387  | 
388  |       static _GLIBCXX20_CONSTEXPR char_type*
389  |       move(char_type* __s1, const char_type* __s2, size_t __n)
390  |       {
391  | 	if (__n == 0)
392  | 	  return __s1;
393  | #ifdef __cpp_lib_is_constant_evaluated
394  | 	if (std::is_constant_evaluated())
395  | 	  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
396  | #endif
397  | 	return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
398  |       }
399  | 
400  |       static _GLIBCXX20_CONSTEXPR char_type*
401  |       copy(char_type* __s1, const char_type* __s2, size_t __n)
402  |       {
403  | 	if (__n == 0)
404  | 	  return __s1;
405  | #ifdef __cpp_lib_is_constant_evaluated
406  | 	if (std::is_constant_evaluated())
407  | 	  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
408  | #endif
409  | 	return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
410  |       }
411  | 
412  |       static _GLIBCXX20_CONSTEXPR char_type*
413  |       assign(char_type* __s, size_t __n, char_type __a)
414  |       {
415  | 	if (__n == 0)
416  | 	  return __s;
417  | #ifdef __cpp_lib_is_constant_evaluated
418  | 	if (std::is_constant_evaluated())
419  | 	  return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
420  | #endif
421  | 	return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
422  |       }
423  | 
424  |       static _GLIBCXX_CONSTEXPR char_type
425  |       to_char_type(const int_type& __c) _GLIBCXX_NOEXCEPT
426  |       { return static_cast<char_type>(__c); }
427  | 
428  |       // To keep both the byte 0xff and the eof symbol 0xffffffff
429  |       // from ending up as 0xffffffff.
430  |       static _GLIBCXX_CONSTEXPR int_type
431  |       to_int_type(const char_type& __c) _GLIBCXX_NOEXCEPT
432  |       { return static_cast<int_type>(static_cast<unsigned char>(__c)); }
433  | 
434  |       static _GLIBCXX_CONSTEXPR bool
435  |       eq_int_type(const int_type& __c1, const int_type& __c2) _GLIBCXX_NOEXCEPT
436  |       { return __c1 == __c2; }
437  | 
438  |       static _GLIBCXX_CONSTEXPR int_type
439  |       eof() _GLIBCXX_NOEXCEPT
440  |       { return static_cast<int_type>(_GLIBCXX_STDIO_EOF); }
441  | 
442  |       static _GLIBCXX_CONSTEXPR int_type
443  |       not_eof(const int_type& __c) _GLIBCXX_NOEXCEPT
444  |       { return (__c == eof()) ? 0 : __c; }
445  |   };
446  | 
447  | 
448  | #ifdef _GLIBCXX_USE_WCHAR_T
449  |   /// 21.1.3.2  char_traits specializations
450  |   template<>
451  |     struct char_traits<wchar_t>
452  |     {
453  |       typedef wchar_t           char_type;
454  |       typedef wint_t            int_type;
455  |       typedef streamoff         off_type;
456  |       typedef wstreampos        pos_type;
457  |       typedef mbstate_t         state_type;
458  | #if __cpp_lib_three_way_comparison
459  |       using comparison_category = strong_ordering;
460  | #endif
461  | 
462  |       static _GLIBCXX17_CONSTEXPR void
463  |       assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
464  |       { __c1 = __c2; }
465  | 
466  |       static _GLIBCXX_CONSTEXPR bool
467  |       eq(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
468  |       { return __c1 == __c2; }
469  | 
470  |       static _GLIBCXX_CONSTEXPR bool
471  |       lt(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
472  |       { return __c1 < __c2; }
473  | 
474  |       static _GLIBCXX17_CONSTEXPR int
475  |       compare(const char_type* __s1, const char_type* __s2, size_t __n)
476  |       {
477  | 	if (__n == 0)
478  | 	  return 0;
479  | #if __cplusplus >= 201703L
480  | 	if (__builtin_constant_p(__n)
481  | 	    && __constant_char_array_p(__s1, __n)
482  | 	    && __constant_char_array_p(__s2, __n))
483  | 	  return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);
484  | #endif
485  | 	return wmemcmp(__s1, __s2, __n);
486  |       }
487  | 
488  |       static _GLIBCXX17_CONSTEXPR size_t
489  |       length(const char_type* __s)
490  |       {
491  | #if __cplusplus >= 201703L
492  | 	if (__constant_string_p(__s))
493  | 	  return __gnu_cxx::char_traits<char_type>::length(__s);
494  | #endif
495  | 	return wcslen(__s);
496  |       }
497  | 
498  |       static _GLIBCXX17_CONSTEXPR const char_type*
499  |       find(const char_type* __s, size_t __n, const char_type& __a)
500  |       {
501  | 	if (__n == 0)
502  | 	  return 0;
503  | #if __cplusplus >= 201703L
504  | 	if (__builtin_constant_p(__n)
505  | 	    && __builtin_constant_p(__a)
506  | 	    && __constant_char_array_p(__s, __n))
507  | 	  return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
508  | #endif
509  | 	return wmemchr(__s, __a, __n);
510  |       }
511  | 
512  |       static _GLIBCXX20_CONSTEXPR char_type*
513  |       move(char_type* __s1, const char_type* __s2, size_t __n)
514  |       {
515  | 	if (__n == 0)
516  | 	  return __s1;
517  | #ifdef __cpp_lib_is_constant_evaluated
518  | 	if (std::is_constant_evaluated())
519  | 	  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
520  | #endif
521  | 	return wmemmove(__s1, __s2, __n);
522  |       }
523  | 
524  |       static _GLIBCXX20_CONSTEXPR char_type*
525  |       copy(char_type* __s1, const char_type* __s2, size_t __n)
526  |       {
527  | 	if (__n == 0)
528  | 	  return __s1;
529  | #ifdef __cpp_lib_is_constant_evaluated
530  | 	if (std::is_constant_evaluated())
531  | 	  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
532  | #endif
533  | 	return wmemcpy(__s1, __s2, __n);
534  |       }
535  | 
536  |       static _GLIBCXX20_CONSTEXPR char_type*
537  |       assign(char_type* __s, size_t __n, char_type __a)
538  |       {
539  | 	if (__n == 0)
540  | 	  return __s;
541  | #ifdef __cpp_lib_is_constant_evaluated
542  | 	if (std::is_constant_evaluated())
543  | 	  return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
544  | #endif
545  | 	return wmemset(__s, __a, __n);
546  |       }
547  | 
548  |       static _GLIBCXX_CONSTEXPR char_type
549  |       to_char_type(const int_type& __c) _GLIBCXX_NOEXCEPT
550  |       { return char_type(__c); }
551  | 
552  |       static _GLIBCXX_CONSTEXPR int_type
553  |       to_int_type(const char_type& __c) _GLIBCXX_NOEXCEPT
554  |       { return int_type(__c); }
555  | 
556  |       static _GLIBCXX_CONSTEXPR bool
557  |       eq_int_type(const int_type& __c1, const int_type& __c2) _GLIBCXX_NOEXCEPT
558  |       { return __c1 == __c2; }
559  | 
560  |       static _GLIBCXX_CONSTEXPR int_type
561  |       eof() _GLIBCXX_NOEXCEPT
562  |       { return static_cast<int_type>(WEOF); }
563  | 
564  |       static _GLIBCXX_CONSTEXPR int_type
565  |       not_eof(const int_type& __c) _GLIBCXX_NOEXCEPT
566  |       { return eq_int_type(__c, eof()) ? 0 : __c; }
567  |   };
568  | #endif //_GLIBCXX_USE_WCHAR_T
569  | 
570  | #ifdef _GLIBCXX_USE_CHAR8_T
571  |   template<>
572  |     struct char_traits<char8_t>
573  |     {
574  |       typedef char8_t           char_type;
575  |       typedef unsigned int      int_type;
576  |       typedef u8streampos       pos_type;
577  |       typedef streamoff         off_type;
578  |       typedef mbstate_t         state_type;
579  | #if __cpp_lib_three_way_comparison
580  |       using comparison_category = strong_ordering;
581  | #endif
582  | 
583  |       static _GLIBCXX17_CONSTEXPR void
584  |       assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
585  |       { __c1 = __c2; }
586  | 
587  |       static _GLIBCXX_CONSTEXPR bool
588  |       eq(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
589  |       { return __c1 == __c2; }
590  | 
591  |       static _GLIBCXX_CONSTEXPR bool
592  |       lt(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
593  |       { return __c1 < __c2; }
594  | 
595  |       static _GLIBCXX17_CONSTEXPR int
596  |       compare(const char_type* __s1, const char_type* __s2, size_t __n)
597  |       {
598  | 	if (__n == 0)
599  | 	  return 0;
600  | #if __cplusplus > 201402
601  | 	if (__builtin_constant_p(__n)
602  | 	    && __constant_char_array_p(__s1, __n)
603  | 	    && __constant_char_array_p(__s2, __n))
604  | 	  return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);
605  | #endif
606  | 	return __builtin_memcmp(__s1, __s2, __n);
607  |       }
608  | 
609  |       static _GLIBCXX17_CONSTEXPR size_t
610  |       length(const char_type* __s)
611  |       {
612  | #if __cplusplus > 201402
613  | 	if (__constant_string_p(__s))
614  | 	  return __gnu_cxx::char_traits<char_type>::length(__s);
615  | #endif
616  | 	size_t __i = 0;
617  | 	while (!eq(__s[__i], char_type()))
618  | 	  ++__i;
619  | 	return __i;
620  |       }
621  | 
622  |       static _GLIBCXX17_CONSTEXPR const char_type*
623  |       find(const char_type* __s, size_t __n, const char_type& __a)
624  |       {
625  | 	if (__n == 0)
626  | 	  return 0;
627  | #if __cplusplus > 201402
628  | 	if (__builtin_constant_p(__n)
629  | 	    && __builtin_constant_p(__a)
630  | 	    && __constant_char_array_p(__s, __n))
631  | 	  return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
632  | #endif
633  | 	return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
634  |       }
635  | 
636  |       static _GLIBCXX20_CONSTEXPR char_type*
637  |       move(char_type* __s1, const char_type* __s2, size_t __n)
638  |       {
639  | 	if (__n == 0)
640  | 	  return __s1;
641  | #ifdef __cpp_lib_is_constant_evaluated
642  | 	if (std::is_constant_evaluated())
643  | 	  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
644  | #endif
645  | 	return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
646  |       }
647  | 
648  |       static _GLIBCXX20_CONSTEXPR char_type*
649  |       copy(char_type* __s1, const char_type* __s2, size_t __n)
650  |       {
651  | 	if (__n == 0)
652  | 	  return __s1;
653  | #ifdef __cpp_lib_is_constant_evaluated
654  | 	if (std::is_constant_evaluated())
655  | 	  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
656  | #endif
657  | 	return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
658  |       }
659  | 
660  |       static _GLIBCXX20_CONSTEXPR char_type*
661  |       assign(char_type* __s, size_t __n, char_type __a)
662  |       {
663  | 	if (__n == 0)
664  | 	  return __s;
665  | #ifdef __cpp_lib_is_constant_evaluated
666  | 	if (std::is_constant_evaluated())
667  | 	  return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
668  | #endif
669  | 	return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
670  |       }
671  | 
672  |       static _GLIBCXX_CONSTEXPR char_type
673  |       to_char_type(const int_type& __c) _GLIBCXX_NOEXCEPT
674  |       { return char_type(__c); }
675  | 
676  |       static _GLIBCXX_CONSTEXPR int_type
677  |       to_int_type(const char_type& __c) _GLIBCXX_NOEXCEPT
678  |       { return int_type(__c); }
679  | 
680  |       static _GLIBCXX_CONSTEXPR bool
681  |       eq_int_type(const int_type& __c1, const int_type& __c2) _GLIBCXX_NOEXCEPT
682  |       { return __c1 == __c2; }
683  | 
684  |       static _GLIBCXX_CONSTEXPR int_type
685  |       eof() _GLIBCXX_NOEXCEPT
686  |       { return static_cast<int_type>(-1); }
687  | 
688  |       static _GLIBCXX_CONSTEXPR int_type
689  |       not_eof(const int_type& __c) _GLIBCXX_NOEXCEPT
690  |       { return eq_int_type(__c, eof()) ? 0 : __c; }
691  |     };
692  | #endif //_GLIBCXX_USE_CHAR8_T
693  | 
694  | _GLIBCXX_END_NAMESPACE_VERSION
695  | } // namespace
696  | 
697  | #if __cplusplus >= 201103L
698  | 
699  | #include <cstdint>
700  | 
701  | namespace std _GLIBCXX_VISIBILITY(default)
702  | {
703  | _GLIBCXX_BEGIN_NAMESPACE_VERSION
704  | 
705  |   template<>
706  |     struct char_traits<char16_t>
707  |     {
708  |       typedef char16_t          char_type;
709  | #ifdef _GLIBCXX_USE_C99_STDINT_TR1
710  |       typedef uint_least16_t    int_type;
711  | #elif defined __UINT_LEAST16_TYPE__
712  |       typedef __UINT_LEAST16_TYPE__	    int_type;
713  | #else
714  |       typedef make_unsigned<char16_t>::type int_type;
715  | #endif
716  |       typedef streamoff         off_type;
717  |       typedef u16streampos      pos_type;
718  |       typedef mbstate_t         state_type;
719  | #if __cpp_lib_three_way_comparison
720  |       using comparison_category = strong_ordering;
721  | #endif
722  | 
723  |       static _GLIBCXX17_CONSTEXPR void
724  |       assign(char_type& __c1, const char_type& __c2) noexcept
725  |       { __c1 = __c2; }
726  | 
727  |       static constexpr bool
728  |       eq(const char_type& __c1, const char_type& __c2) noexcept
729  |       { return __c1 == __c2; }
730  | 
731  |       static constexpr bool
732  |       lt(const char_type& __c1, const char_type& __c2) noexcept
733  |       { return __c1 < __c2; }
734  | 
735  |       static _GLIBCXX17_CONSTEXPR int
736  |       compare(const char_type* __s1, const char_type* __s2, size_t __n)
737  |       {
738  | 	for (size_t __i = 0; __i < __n; ++__i)
739  | 	  if (lt(__s1[__i], __s2[__i]))
740  | 	    return -1;
741  | 	  else if (lt(__s2[__i], __s1[__i]))
742  | 	    return 1;
743  | 	return 0;
744  |       }
745  | 
746  |       static _GLIBCXX17_CONSTEXPR size_t
747  |       length(const char_type* __s)
748  |       {
749  | 	size_t __i = 0;
750  | 	while (!eq(__s[__i], char_type()))
751  | 	  ++__i;
752  | 	return __i;
753  |       }
754  | 
755  |       static _GLIBCXX17_CONSTEXPR const char_type*
756  |       find(const char_type* __s, size_t __n, const char_type& __a)
757  |       {
758  | 	for (size_t __i = 0; __i < __n; ++__i)
759  | 	  if (eq(__s[__i], __a))
760  | 	    return __s + __i;
761  | 	return 0;
762  |       }
763  | 
764  |       static _GLIBCXX20_CONSTEXPR char_type*
765  |       move(char_type* __s1, const char_type* __s2, size_t __n)
766  |       {
767  | 	if (__n == 0)
768  | 	  return __s1;
769  | #ifdef __cpp_lib_is_constant_evaluated
770  | 	if (std::is_constant_evaluated())
771  | 	  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
772  | #endif
773  | 	return (static_cast<char_type*>
774  | 		(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
775  |       }
776  | 
777  |       static _GLIBCXX20_CONSTEXPR char_type*
778  |       copy(char_type* __s1, const char_type* __s2, size_t __n)
779  |       {
780  | 	if (__n == 0)
781  | 	  return __s1;
782  | #ifdef __cpp_lib_is_constant_evaluated
783  | 	if (std::is_constant_evaluated())
784  | 	  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
785  | #endif
786  | 	return (static_cast<char_type*>
787  | 		(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
788  |       }
789  | 
790  |       static _GLIBCXX20_CONSTEXPR char_type*
791  |       assign(char_type* __s, size_t __n, char_type __a)
792  |       {
793  | 	for (size_t __i = 0; __i < __n; ++__i)
794  | 	  assign(__s[__i], __a);
795  | 	return __s;
796  |       }
797  | 
798  |       static constexpr char_type
799  |       to_char_type(const int_type& __c) noexcept
800  |       { return char_type(__c); }
801  | 
802  |       static constexpr int_type
803  |       to_int_type(const char_type& __c) noexcept
804  |       { return __c == eof() ? int_type(0xfffd) : int_type(__c); }
805  | 
806  |       static constexpr bool
807  |       eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
808  |       { return __c1 == __c2; }
809  | 
810  |       static constexpr int_type
811  |       eof() noexcept
812  |       { return static_cast<int_type>(-1); }
813  | 
814  |       static constexpr int_type
815  |       not_eof(const int_type& __c) noexcept
816  |       { return eq_int_type(__c, eof()) ? 0 : __c; }
817  |     };
818  | 
819  |   template<>
820  |     struct char_traits<char32_t>
821  |     {
822  |       typedef char32_t          char_type;
823  | #ifdef _GLIBCXX_USE_C99_STDINT_TR1
824  |       typedef uint_least32_t    int_type;
825  | #elif defined __UINT_LEAST32_TYPE__
826  |       typedef __UINT_LEAST32_TYPE__	    int_type;
827  | #else
828  |       typedef make_unsigned<char32_t>::type int_type;
829  | #endif
830  |       typedef streamoff         off_type;
831  |       typedef u32streampos      pos_type;
832  |       typedef mbstate_t         state_type;
833  | #if __cpp_lib_three_way_comparison
834  |       using comparison_category = strong_ordering;
835  | #endif
836  | 
837  |       static _GLIBCXX17_CONSTEXPR void
838  |       assign(char_type& __c1, const char_type& __c2) noexcept
839  |       { __c1 = __c2; }
840  | 
841  |       static constexpr bool
842  |       eq(const char_type& __c1, const char_type& __c2) noexcept
843  |       { return __c1 == __c2; }
844  | 
845  |       static constexpr bool
846  |       lt(const char_type& __c1, const char_type& __c2) noexcept
847  |       { return __c1 < __c2; }
848  | 
849  |       static _GLIBCXX17_CONSTEXPR int
850  |       compare(const char_type* __s1, const char_type* __s2, size_t __n)
851  |       {
852  | 	for (size_t __i = 0; __i < __n; ++__i)
853  | 	  if (lt(__s1[__i], __s2[__i]))
854  | 	    return -1;
855  | 	  else if (lt(__s2[__i], __s1[__i]))
856  | 	    return 1;
857  | 	return 0;
858  |       }
859  | 
860  |       static _GLIBCXX17_CONSTEXPR size_t
861  |       length(const char_type* __s)
862  |       {
863  | 	size_t __i = 0;
864  | 	while (!eq(__s[__i], char_type()))
865  | 	  ++__i;
866  | 	return __i;
867  |       }
868  | 
869  |       static _GLIBCXX17_CONSTEXPR const char_type*
870  |       find(const char_type* __s, size_t __n, const char_type& __a)
871  |       {
872  | 	for (size_t __i = 0; __i < __n; ++__i)
873  | 	  if (eq(__s[__i], __a))
874  | 	    return __s + __i;
875  | 	return 0;
876  |       }
877  | 
878  |       static _GLIBCXX20_CONSTEXPR char_type*
879  |       move(char_type* __s1, const char_type* __s2, size_t __n)
880  |       {
881  | 	if (__n == 0)
882  | 	  return __s1;
883  | #ifdef __cpp_lib_is_constant_evaluated
884  | 	if (std::is_constant_evaluated())
885  | 	  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
886  | #endif
887  | 	return (static_cast<char_type*>
888  | 		(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
889  |       }
890  | 
891  |       static _GLIBCXX20_CONSTEXPR char_type*
892  |       copy(char_type* __s1, const char_type* __s2, size_t __n)
893  |       { 
894  | 	if (__n == 0)
895  | 	  return __s1;
896  | #ifdef __cpp_lib_is_constant_evaluated
897  | 	if (std::is_constant_evaluated())
898  | 	  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
899  | #endif
900  | 	return (static_cast<char_type*>
901  | 		(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
902  |       }
903  | 
904  |       static _GLIBCXX20_CONSTEXPR char_type*
905  |       assign(char_type* __s, size_t __n, char_type __a)
906  |       {
907  | 	for (size_t __i = 0; __i < __n; ++__i)
908  | 	  assign(__s[__i], __a);
909  | 	return __s;
910  |       }
911  | 
912  |       static constexpr char_type
913  |       to_char_type(const int_type& __c) noexcept
914  |       { return char_type(__c); }
915  | 
916  |       static constexpr int_type
917  |       to_int_type(const char_type& __c) noexcept
918  |       { return int_type(__c); }
919  | 
920  |       static constexpr bool
921  |       eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
922  |       { return __c1 == __c2; }
923  | 
924  |       static constexpr int_type
925  |       eof() noexcept
926  |       { return static_cast<int_type>(-1); }
927  | 
928  |       static constexpr int_type
929  |       not_eof(const int_type& __c) noexcept
930  |       { return eq_int_type(__c, eof()) ? 0 : __c; }
931  |     };
932  | 
933  | #if __cpp_lib_three_way_comparison
934  |   namespace __detail
935  |   {
936  |     template<typename _ChTraits>
937  |       constexpr auto
938  |       __char_traits_cmp_cat(int __cmp) noexcept
939  |       {
940  | 	if constexpr (requires { typename _ChTraits::comparison_category; })
941  | 	  {
942  | 	    using _Cat = typename _ChTraits::comparison_category;
943  | 	    static_assert( !is_void_v<common_comparison_category_t<_Cat>> );
944  | 	    return static_cast<_Cat>(__cmp <=> 0);
945  | 	  }
946  | 	else
947  | 	  return static_cast<weak_ordering>(__cmp <=> 0);
948  |       }
949  |   } // namespace __detail
950  | #endif // C++20
951  | 
952  | _GLIBCXX_END_NAMESPACE_VERSION
953  | } // namespace
954  | 
955  | #endif  // C++11
956  | 
957  | #endif // _CHAR_TRAITS_H

< /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/locale_facets.h
   1  | // Locale support -*- C++ -*-
   2  | 
   3  | // Copyright (C) 1997-2021 Free Software Foundation, Inc.
   4  | //
   5  | // This file is part of the GNU ISO C++ Library.  This library is free
   6  | // software; you can redistribute it and/or modify it under the
   7  | // terms of the GNU General Public License as published by the
   8  | // Free Software Foundation; either version 3, or (at your option)
   9  | // any later version.
  10  | 
  11  | // This library is distributed in the hope that it will be useful,
  12  | // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  | // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14  | // GNU General Public License for more details.
  15  | 
  16  | // Under Section 7 of GPL version 3, you are granted additional
  17  | // permissions described in the GCC Runtime Library Exception, version
  18  | // 3.1, as published by the Free Software Foundation.
  19  | 
  20  | // You should have received a copy of the GNU General Public License and
  21  | // a copy of the GCC Runtime Library Exception along with this program;
  22  | // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23  | // <http://www.gnu.org/licenses/>.
  24  | 
  25  | /** @file bits/locale_facets.h
  26  |  *  This is an internal header file, included by other library headers.
  27  |  *  Do not attempt to use it directly. @headername{locale}
  28  |  */
  29  | 
  30  | //
  31  | // ISO C++ 14882: 22.1  Locales
  32  | //
  33  | 
  34  | #ifndef _LOCALE_FACETS_H
  35  | #define _LOCALE_FACETS_H 1
  36  | 
  37  | #pragma GCC system_header
  38  | 
  39  | #include <cwctype>	// For wctype_t
  40  | #include <cctype>
  41  | #include <bits/ctype_base.h>
  42  | #include <iosfwd>
  43  | #include <bits/ios_base.h>  // For ios_base, ios_base::iostate
  44  | #include <streambuf>
  45  | #include <bits/cpp_type_traits.h>
  46  | #include <ext/type_traits.h>
  47  | #include <ext/numeric_traits.h>
  48  | #include <bits/streambuf_iterator.h>
  49  | 
  50  | namespace std _GLIBCXX_VISIBILITY(default)
  51  | {
  52  | _GLIBCXX_BEGIN_NAMESPACE_VERSION
  53  | 
  54  | // Number of standard facets (for narrow characters only)
  55  | #define  _GLIBCXX_NUM_FACETS 14
  56  | 
  57  | // Number of duplicated facets for cxx11 ABI
  58  | #define  _GLIBCXX_NUM_CXX11_FACETS (_GLIBCXX_USE_DUAL_ABI ? 8 : 0)
  59  | 
  60  | // codecvt<char16_t> and codecvt<char32_t>
  61  | #ifdef _GLIBCXX_USE_CHAR8_T
  62  | # define _GLIBCXX_NUM_UNICODE_FACETS 4
  63  | #else
  64  | # define _GLIBCXX_NUM_UNICODE_FACETS 2
  65  | #endif
  66  | 
  67  | // Facets duplicated for alt128 long double format
  68  | // num_get, num_put, money_get, money_put (+ cxx11 money_get, money_put)
  69  | #define _GLIBCXX_NUM_LBDL_ALT128_FACETS (4 + (_GLIBCXX_USE_DUAL_ABI ? 2 : 0))
  70  | 
  71  |   // Convert string to numeric value of type _Tp and store results.
  72  |   // NB: This is specialized for all required types, there is no
  73  |   // generic definition.
  74  |   template<typename _Tp>
  75  |     void
  76  |     __convert_to_v(const char*, _Tp&, ios_base::iostate&,
  77  | 		   const __c_locale&) throw();
  78  | 
  79  |   // Explicit specializations for required types.
  80  |   template<>
  81  |     void
  82  |     __convert_to_v(const char*, float&, ios_base::iostate&,
  83  | 		   const __c_locale&) throw();
  84  | 
  85  |   template<>
  86  |     void
  87  |     __convert_to_v(const char*, double&, ios_base::iostate&,
  88  | 		   const __c_locale&) throw();
  89  | 
  90  |   template<>
  91  |     void
  92  |     __convert_to_v(const char*, long double&, ios_base::iostate&,
  93  | 		   const __c_locale&) throw();
  94  | 
  95  |   // NB: __pad is a struct, rather than a function, so it can be
  96  |   // partially-specialized.
  97  |   template<typename _CharT, typename _Traits>
  98  |     struct __pad
  99  |     {
 100  |       static void
 101  |       _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
 102  | 	     const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
 103  |     };
 104  | 
 105  |   // Used by both numeric and monetary facets.
 106  |   // Inserts "group separator" characters into an array of characters.
 107  |   // It's recursive, one iteration per group.  It moves the characters
 108  |   // in the buffer this way: "xxxx12345" -> "12,345xxx".  Call this
 109  |   // only with __gsize != 0.
 110  |   template<typename _CharT>
 111  |     _CharT*
 112  |     __add_grouping(_CharT* __s, _CharT __sep,
 113  | 		   const char* __gbeg, size_t __gsize,
 114  | 		   const _CharT* __first, const _CharT* __last);
 115  | 
 116  |   // This template permits specializing facet output code for
 117  |   // ostreambuf_iterator.  For ostreambuf_iterator, sputn is
 118  |   // significantly more efficient than incrementing iterators.
 119  |   template<typename _CharT>
 120  |     inline
 121  |     ostreambuf_iterator<_CharT>
 122  |     __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
 123  |     {
 124  |       __s._M_put(__ws, __len);
 125  |       return __s;
 126  |     }
 127  | 
 128  |   // This is the unspecialized form of the template.
 129  |   template<typename _CharT, typename _OutIter>
 130  |     inline
 131  |     _OutIter
 132  |     __write(_OutIter __s, const _CharT* __ws, int __len)
 133  |     {
 134  |       for (int __j = 0; __j < __len; __j++, ++__s)
 135  | 	*__s = __ws[__j];
 136  |       return __s;
 137  |     }
 138  | 
 139  | 
 140  |   // 22.2.1.1  Template class ctype
 141  |   // Include host and configuration specific ctype enums for ctype_base.
 142  | 
 143  |   /**
 144  |    *  @brief  Common base for ctype facet
 145  |    *
 146  |    *  This template class provides implementations of the public functions
 147  |    *  that forward to the protected virtual functions.
 148  |    *
 149  |    *  This template also provides abstract stubs for the protected virtual
 150  |    *  functions.
 151  |   */
 152  |   template<typename _CharT>
 153  |     class __ctype_abstract_base : public locale::facet, public ctype_base
 154  |     {
 155  |     public:
 156  |       // Types:
 157  |       /// Typedef for the template parameter
 158  |       typedef _CharT char_type;
 159  | 
 160  |       /**
 161  |        *  @brief  Test char_type classification.
 162  |        *
 163  |        *  This function finds a mask M for @a __c and compares it to
 164  |        *  mask @a __m.  It does so by returning the value of
 165  |        *  ctype<char_type>::do_is().
 166  |        *
 167  |        *  @param __c  The char_type to compare the mask of.
 168  |        *  @param __m  The mask to compare against.
 169  |        *  @return  (M & __m) != 0.
 170  |       */
 171  |       bool
 172  |       is(mask __m, char_type __c) const
 173  |       { return this->do_is(__m, __c); }
 174  | 
 175  |       /**
 176  |        *  @brief  Return a mask array.
 177  |        *
 178  |        *  This function finds the mask for each char_type in the range [lo,hi)
 179  |        *  and successively writes it to vec.  vec must have as many elements
 180  |        *  as the char array.  It does so by returning the value of
 181  |        *  ctype<char_type>::do_is().
 182  |        *
 183  |        *  @param __lo  Pointer to start of range.
 184  |        *  @param __hi  Pointer to end of range.
 185  |        *  @param __vec  Pointer to an array of mask storage.
 186  |        *  @return  @a __hi.
 187  |       */
 188  |       const char_type*
 189  |       is(const char_type *__lo, const char_type *__hi, mask *__vec) const
 190  |       { return this->do_is(__lo, __hi, __vec); }
 191  | 
 192  |       /**
 193  |        *  @brief  Find char_type matching a mask
 194  |        *
 195  |        *  This function searches for and returns the first char_type c in
 196  |        *  [lo,hi) for which is(m,c) is true.  It does so by returning
 197  |        *  ctype<char_type>::do_scan_is().
 198  |        *
 199  |        *  @param __m  The mask to compare against.
 200  |        *  @param __lo  Pointer to start of range.
 201  |        *  @param __hi  Pointer to end of range.
 202  |        *  @return  Pointer to matching char_type if found, else @a __hi.
 203  |       */
 204  |       const char_type*
 205  |       scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
 206  |       { return this->do_scan_is(__m, __lo, __hi); }
 207  | 
 208  |       /**
 209  |        *  @brief  Find char_type not matching a mask
 210  |        *
 211  |        *  This function searches for and returns the first char_type c in
 212  |        *  [lo,hi) for which is(m,c) is false.  It does so by returning
 213  |        *  ctype<char_type>::do_scan_not().
 214  |        *
 215  |        *  @param __m  The mask to compare against.
 216  |        *  @param __lo  Pointer to first char in range.
 217  |        *  @param __hi  Pointer to end of range.
 218  |        *  @return  Pointer to non-matching char if found, else @a __hi.
 219  |       */
 220  |       const char_type*
 221  |       scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
 222  |       { return this->do_scan_not(__m, __lo, __hi); }
 223  | 
 224  |       /**
 225  |        *  @brief  Convert to uppercase.
 226  |        *
 227  |        *  This function converts the argument to uppercase if possible.
 228  |        *  If not possible (for example, '2'), returns the argument.  It does
 229  |        *  so by returning ctype<char_type>::do_toupper().
 230  |        *
 231  |        *  @param __c  The char_type to convert.
 232  |        *  @return  The uppercase char_type if convertible, else @a __c.
 233  |       */
 234  |       char_type
 235  |       toupper(char_type __c) const
 236  |       { return this->do_toupper(__c); }
 237  | 
 238  |       /**
 239  |        *  @brief  Convert array to uppercase.
 240  |        *
 241  |        *  This function converts each char_type in the range [lo,hi) to
 242  |        *  uppercase if possible.  Other elements remain untouched.  It does so
 243  |        *  by returning ctype<char_type>:: do_toupper(lo, hi).
 244  |        *
 245  |        *  @param __lo  Pointer to start of range.
 246  |        *  @param __hi  Pointer to end of range.
 247  |        *  @return  @a __hi.
 248  |       */
 249  |       const char_type*
 250  |       toupper(char_type *__lo, const char_type* __hi) const
 251  |       { return this->do_toupper(__lo, __hi); }
 252  | 
 253  |       /**
 254  |        *  @brief  Convert to lowercase.
 255  |        *
 256  |        *  This function converts the argument to lowercase if possible.  If
 257  |        *  not possible (for example, '2'), returns the argument.  It does so
 258  |        *  by returning ctype<char_type>::do_tolower(c).
 259  |        *
 260  |        *  @param __c  The char_type to convert.
 261  |        *  @return  The lowercase char_type if convertible, else @a __c.
 262  |       */
 263  |       char_type
 264  |       tolower(char_type __c) const
 265  |       { return this->do_tolower(__c); }
 266  | 
 267  |       /**
 268  |        *  @brief  Convert array to lowercase.
 269  |        *
 270  |        *  This function converts each char_type in the range [__lo,__hi) to
 271  |        *  lowercase if possible.  Other elements remain untouched.  It does so
 272  |        *  by returning ctype<char_type>:: do_tolower(__lo, __hi).
 273  |        *
 274  |        *  @param __lo  Pointer to start of range.
 275  |        *  @param __hi  Pointer to end of range.
 276  |        *  @return  @a __hi.
 277  |       */
 278  |       const char_type*
 279  |       tolower(char_type* __lo, const char_type* __hi) const
 280  |       { return this->do_tolower(__lo, __hi); }
 281  | 
 282  |       /**
 283  |        *  @brief  Widen char to char_type
 284  |        *
 285  |        *  This function converts the char argument to char_type using the
 286  |        *  simplest reasonable transformation.  It does so by returning
 287  |        *  ctype<char_type>::do_widen(c).
 288  |        *
 289  |        *  Note: this is not what you want for codepage conversions.  See
 290  |        *  codecvt for that.
 291  |        *
 292  |        *  @param __c  The char to convert.
 293  |        *  @return  The converted char_type.
 294  |       */
 295  |       char_type
 296  |       widen(char __c) const
 297  |       { return this->do_widen(__c); }
 298  | 
 299  |       /**
 300  |        *  @brief  Widen array to char_type
 301  |        *
 302  |        *  This function converts each char in the input to char_type using the
 303  |        *  simplest reasonable transformation.  It does so by returning
 304  |        *  ctype<char_type>::do_widen(c).
 305  |        *
 306  |        *  Note: this is not what you want for codepage conversions.  See
 307  |        *  codecvt for that.
 308  |        *
 309  |        *  @param __lo  Pointer to start of range.
 310  |        *  @param __hi  Pointer to end of range.
 311  |        *  @param __to  Pointer to the destination array.
 312  |        *  @return  @a __hi.
 313  |       */
 314  |       const char*
 315  |       widen(const char* __lo, const char* __hi, char_type* __to) const
 316  |       { return this->do_widen(__lo, __hi, __to); }
 317  | 
 318  |       /**
 319  |        *  @brief  Narrow char_type to char
 320  |        *
 321  |        *  This function converts the char_type to char using the simplest
 322  |        *  reasonable transformation.  If the conversion fails, dfault is
 323  |        *  returned instead.  It does so by returning
 324  |        *  ctype<char_type>::do_narrow(__c).
 325  |        *
 326  |        *  Note: this is not what you want for codepage conversions.  See
 327  |        *  codecvt for that.
 328  |        *
 329  |        *  @param __c  The char_type to convert.
 330  |        *  @param __dfault  Char to return if conversion fails.
 331  |        *  @return  The converted char.
 332  |       */
 333  |       char
 334  |       narrow(char_type __c, char __dfault) const
 335  |       { return this->do_narrow(__c, __dfault); }
 336  | 
 337  |       /**
 338  |        *  @brief  Narrow array to char array
 339  |        *
 340  |        *  This function converts each char_type in the input to char using the
 341  |        *  simplest reasonable transformation and writes the results to the
 342  |        *  destination array.  For any char_type in the input that cannot be
 343  |        *  converted, @a dfault is used instead.  It does so by returning
 344  |        *  ctype<char_type>::do_narrow(__lo, __hi, __dfault, __to).
 345  |        *
 346  |        *  Note: this is not what you want for codepage conversions.  See
 347  |        *  codecvt for that.
 348  |        *
 349  |        *  @param __lo  Pointer to start of range.
 350  |        *  @param __hi  Pointer to end of range.
 351  |        *  @param __dfault  Char to use if conversion fails.
 352  |        *  @param __to  Pointer to the destination array.
 353  |        *  @return  @a __hi.
 354  |       */
 355  |       const char_type*
 356  |       narrow(const char_type* __lo, const char_type* __hi,
 357  | 	      char __dfault, char* __to) const
 358  |       { return this->do_narrow(__lo, __hi, __dfault, __to); }
 359  | 
 360  |     protected:
 361  |       explicit
 362  |       __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }
 363  | 
 364  |       virtual
 365  |       ~__ctype_abstract_base() { }
 366  | 
 367  |       /**
 368  |        *  @brief  Test char_type classification.
 369  |        *
 370  |        *  This function finds a mask M for @a c and compares it to mask @a m.
 371  |        *
 372  |        *  do_is() is a hook for a derived facet to change the behavior of
 373  |        *  classifying.  do_is() must always return the same result for the
 374  |        *  same input.
 375  |        *
 376  |        *  @param __c  The char_type to find the mask of.
 377  |        *  @param __m  The mask to compare against.
 378  |        *  @return  (M & __m) != 0.
 379  |       */
 380  |       virtual bool
 381  |       do_is(mask __m, char_type __c) const = 0;
 382  | 
 383  |       /**
 384  |        *  @brief  Return a mask array.
 385  |        *
 386  |        *  This function finds the mask for each char_type in the range [lo,hi)
 387  |        *  and successively writes it to vec.  vec must have as many elements
 388  |        *  as the input.
 389  |        *
 390  |        *  do_is() is a hook for a derived facet to change the behavior of
 391  |        *  classifying.  do_is() must always return the same result for the
 392  |        *  same input.
 393  |        *
 394  |        *  @param __lo  Pointer to start of range.
 395  |        *  @param __hi  Pointer to end of range.
 396  |        *  @param __vec  Pointer to an array of mask storage.
 397  |        *  @return  @a __hi.
 398  |       */
 399  |       virtual const char_type*
 400  |       do_is(const char_type* __lo, const char_type* __hi,
 401  | 	    mask* __vec) const = 0;
 402  | 
 403  |       /**
 404  |        *  @brief  Find char_type matching mask
 405  |        *
 406  |        *  This function searches for and returns the first char_type c in
 407  |        *  [__lo,__hi) for which is(__m,c) is true.
 408  |        *
 409  |        *  do_scan_is() is a hook for a derived facet to change the behavior of
 410  |        *  match searching.  do_is() must always return the same result for the
 411  |        *  same input.
 412  |        *
 413  |        *  @param __m  The mask to compare against.
 414  |        *  @param __lo  Pointer to start of range.
 415  |        *  @param __hi  Pointer to end of range.
 416  |        *  @return  Pointer to a matching char_type if found, else @a __hi.
 417  |       */
 418  |       virtual const char_type*
 419  |       do_scan_is(mask __m, const char_type* __lo,
 420  | 		 const char_type* __hi) const = 0;
 421  | 
 422  |       /**
 423  |        *  @brief  Find char_type not matching mask
 424  |        *
 425  |        *  This function searches for and returns a pointer to the first
 426  |        *  char_type c of [lo,hi) for which is(m,c) is false.
 427  |        *
 428  |        *  do_scan_is() is a hook for a derived facet to change the behavior of
 429  |        *  match searching.  do_is() must always return the same result for the
 430  |        *  same input.
 431  |        *
 432  |        *  @param __m  The mask to compare against.
 433  |        *  @param __lo  Pointer to start of range.
 434  |        *  @param __hi  Pointer to end of range.
 435  |        *  @return  Pointer to a non-matching char_type if found, else @a __hi.
 436  |       */
 437  |       virtual const char_type*
 438  |       do_scan_not(mask __m, const char_type* __lo,
 439  | 		  const char_type* __hi) const = 0;
 440  | 
 441  |       /**
 442  |        *  @brief  Convert to uppercase.
 443  |        *
 444  |        *  This virtual function converts the char_type argument to uppercase
 445  |        *  if possible.  If not possible (for example, '2'), returns the
 446  |        *  argument.
 447  |        *
 448  |        *  do_toupper() is a hook for a derived facet to change the behavior of
 449  |        *  uppercasing.  do_toupper() must always return the same result for
 450  |        *  the same input.
 451  |        *
 452  |        *  @param __c  The char_type to convert.
 453  |        *  @return  The uppercase char_type if convertible, else @a __c.
 454  |       */
 455  |       virtual char_type
 456  |       do_toupper(char_type __c) const = 0;
 457  | 
 458  |       /**
 459  |        *  @brief  Convert array to uppercase.
 460  |        *
 461  |        *  This virtual function converts each char_type in the range [__lo,__hi)
 462  |        *  to uppercase if possible.  Other elements remain untouched.
 463  |        *
 464  |        *  do_toupper() is a hook for a derived facet to change the behavior of
 465  |        *  uppercasing.  do_toupper() must always return the same result for
 466  |        *  the same input.
 467  |        *
 468  |        *  @param __lo  Pointer to start of range.
 469  |        *  @param __hi  Pointer to end of range.
 470  |        *  @return  @a __hi.
 471  |       */
 472  |       virtual const char_type*
 473  |       do_toupper(char_type* __lo, const char_type* __hi) const = 0;
 474  | 
 475  |       /**
 476  |        *  @brief  Convert to lowercase.
 477  |        *
 478  |        *  This virtual function converts the argument to lowercase if
 479  |        *  possible.  If not possible (for example, '2'), returns the argument.
 480  |        *
 481  |        *  do_tolower() is a hook for a derived facet to change the behavior of
 482  |        *  lowercasing.  do_tolower() must always return the same result for
 483  |        *  the same input.
 484  |        *
 485  |        *  @param __c  The char_type to convert.
 486  |        *  @return  The lowercase char_type if convertible, else @a __c.
 487  |       */
 488  |       virtual char_type
 489  |       do_tolower(char_type __c) const = 0;
 490  | 
 491  |       /**
 492  |        *  @brief  Convert array to lowercase.
 493  |        *
 494  |        *  This virtual function converts each char_type in the range [__lo,__hi)
 495  |        *  to lowercase if possible.  Other elements remain untouched.
 496  |        *
 497  |        *  do_tolower() is a hook for a derived facet to change the behavior of
 498  |        *  lowercasing.  do_tolower() must always return the same result for
 499  |        *  the same input.
 500  |        *
 501  |        *  @param __lo  Pointer to start of range.
 502  |        *  @param __hi  Pointer to end of range.
 503  |        *  @return  @a __hi.
 504  |       */
 505  |       virtual const char_type*
 506  |       do_tolower(char_type* __lo, const char_type* __hi) const = 0;
 507  | 
 508  |       /**
 509  |        *  @brief  Widen char
 510  |        *
 511  |        *  This virtual function converts the char to char_type using the
 512  |        *  simplest reasonable transformation.
 513  |        *
 514  |        *  do_widen() is a hook for a derived facet to change the behavior of
 515  |        *  widening.  do_widen() must always return the same result for the
 516  |        *  same input.
 517  |        *
 518  |        *  Note: this is not what you want for codepage conversions.  See
 519  |        *  codecvt for that.
 520  |        *
 521  |        *  @param __c  The char to convert.
 522  |        *  @return  The converted char_type
 523  |       */
 524  |       virtual char_type
 525  |       do_widen(char __c) const = 0;
 526  | 
 527  |       /**
 528  |        *  @brief  Widen char array
 529  |        *
 530  |        *  This function converts each char in the input to char_type using the
 531  |        *  simplest reasonable transformation.
 532  |        *
 533  |        *  do_widen() is a hook for a derived facet to change the behavior of
 534  |        *  widening.  do_widen() must always return the same result for the
 535  |        *  same input.
 536  |        *
 537  |        *  Note: this is not what you want for codepage conversions.  See
 538  |        *  codecvt for that.
 539  |        *
 540  |        *  @param __lo  Pointer to start range.
 541  |        *  @param __hi  Pointer to end of range.
 542  |        *  @param __to  Pointer to the destination array.
 543  |        *  @return  @a __hi.
 544  |       */
 545  |       virtual const char*
 546  |       do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
 547  | 
 548  |       /**
 549  |        *  @brief  Narrow char_type to char
 550  |        *
 551  |        *  This virtual function converts the argument to char using the
 552  |        *  simplest reasonable transformation.  If the conversion fails, dfault
 553  |        *  is returned instead.
 554  |        *
 555  |        *  do_narrow() is a hook for a derived facet to change the behavior of
 556  |        *  narrowing.  do_narrow() must always return the same result for the
 557  |        *  same input.
 558  |        *
 559  |        *  Note: this is not what you want for codepage conversions.  See
 560  |        *  codecvt for that.
 561  |        *
 562  |        *  @param __c  The char_type to convert.
 563  |        *  @param __dfault  Char to return if conversion fails.
 564  |        *  @return  The converted char.
 565  |       */
 566  |       virtual char
 567  |       do_narrow(char_type __c, char __dfault) const = 0;
 568  | 
 569  |       /**
 570  |        *  @brief  Narrow char_type array to char
 571  |        *
 572  |        *  This virtual function converts each char_type in the range
 573  |        *  [__lo,__hi) to char using the simplest reasonable
 574  |        *  transformation and writes the results to the destination
 575  |        *  array.  For any element in the input that cannot be
 576  |        *  converted, @a __dfault is used instead.
 577  |        *
 578  |        *  do_narrow() is a hook for a derived facet to change the behavior of
 579  |        *  narrowing.  do_narrow() must always return the same result for the
 580  |        *  same input.
 581  |        *
 582  |        *  Note: this is not what you want for codepage conversions.  See
 583  |        *  codecvt for that.
 584  |        *
 585  |        *  @param __lo  Pointer to start of range.
 586  |        *  @param __hi  Pointer to end of range.
 587  |        *  @param __dfault  Char to use if conversion fails.
 588  |        *  @param __to  Pointer to the destination array.
 589  |        *  @return  @a __hi.
 590  |       */
 591  |       virtual const char_type*
 592  |       do_narrow(const char_type* __lo, const char_type* __hi,
 593  | 		char __dfault, char* __to) const = 0;
 594  |     };
 595  | 
 596  |   /**
 597  |    *  @brief  Primary class template ctype facet.
 598  |    *  @ingroup locales
 599  |    *
 600  |    *  This template class defines classification and conversion functions for
 601  |    *  character sets.  It wraps cctype functionality.  Ctype gets used by
 602  |    *  streams for many I/O operations.
 603  |    *
 604  |    *  This template provides the protected virtual functions the developer
 605  |    *  will have to replace in a derived class or specialization to make a
 606  |    *  working facet.  The public functions that access them are defined in
 607  |    *  __ctype_abstract_base, to allow for implementation flexibility.  See
 608  |    *  ctype<wchar_t> for an example.  The functions are documented in
 609  |    *  __ctype_abstract_base.
 610  |    *
 611  |    *  Note: implementations are provided for all the protected virtual
 612  |    *  functions, but will likely not be useful.
 613  |   */
 614  |   template<typename _CharT>
 615  |     class ctype : public __ctype_abstract_base<_CharT>
 616  |     {
 617  |     public:
 618  |       // Types:
 619  |       typedef _CharT			char_type;
 620  |       typedef typename __ctype_abstract_base<_CharT>::mask mask;
 621  | 
 622  |       /// The facet id for ctype<char_type>
 623  |       static locale::id			id;
 624  | 
 625  |       explicit
 626  |       ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }
 627  | 
 628  |    protected:
 629  |       virtual
 630  |       ~ctype();
 631  | 
 632  |       virtual bool
 633  |       do_is(mask __m, char_type __c) const;
 634  | 
 635  |       virtual const char_type*
 636  |       do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
 637  | 
 638  |       virtual const char_type*
 639  |       do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
 640  | 
 641  |       virtual const char_type*
 642  |       do_scan_not(mask __m, const char_type* __lo,
 643  | 		  const char_type* __hi) const;
 644  | 
 645  |       virtual char_type
 646  |       do_toupper(char_type __c) const;
 647  | 
 648  |       virtual const char_type*
 649  |       do_toupper(char_type* __lo, const char_type* __hi) const;
 650  | 
 651  |       virtual char_type
 652  |       do_tolower(char_type __c) const;
 653  | 
 654  |       virtual const char_type*
 655  |       do_tolower(char_type* __lo, const char_type* __hi) const;
 656  | 
 657  |       virtual char_type
 658  |       do_widen(char __c) const;
 659  | 
 660  |       virtual const char*
 661  |       do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
 662  | 
 663  |       virtual char
 664  |       do_narrow(char_type, char __dfault) const;
 665  | 
 666  |       virtual const char_type*
 667  |       do_narrow(const char_type* __lo, const char_type* __hi,
 668  | 		char __dfault, char* __to) const;
 669  |     };
 670  | 
 671  |   template<typename _CharT>
 672  |     locale::id ctype<_CharT>::id;
 673  | 
 674  |   /**
 675  |    *  @brief  The ctype<char> specialization.
 676  |    *  @ingroup locales
 677  |    *
 678  |    *  This class defines classification and conversion functions for
 679  |    *  the char type.  It gets used by char streams for many I/O
 680  |    *  operations.  The char specialization provides a number of
 681  |    *  optimizations as well.
 682  |   */
 683  |   template<>
 684  |     class ctype<char> : public locale::facet, public ctype_base
 685  |     {
 686  |     public:
 687  |       // Types:
 688  |       /// Typedef for the template parameter char.
 689  |       typedef char		char_type;
 690  | 
 691  |     protected:
 692  |       // Data Members:
 693  |       __c_locale		_M_c_locale_ctype;
 694  |       bool			_M_del;
 695  |       __to_type			_M_toupper;
 696  |       __to_type			_M_tolower;
 697  |       const mask*		_M_table;
 698  |       mutable char		_M_widen_ok;
 699  |       mutable char		_M_widen[1 + static_cast<unsigned char>(-1)];
 700  |       mutable char		_M_narrow[1 + static_cast<unsigned char>(-1)];
 701  |       mutable char		_M_narrow_ok;	// 0 uninitialized, 1 init,
 702  | 						// 2 memcpy can't be used
 703  | 
 704  |     public:
 705  |       /// The facet id for ctype<char>
 706  |       static locale::id        id;
 707  |       /// The size of the mask table.  It is SCHAR_MAX + 1.
 708  |       static const size_t      table_size = 1 + static_cast<unsigned char>(-1);
 709  | 
 710  |       /**
 711  |        *  @brief  Constructor performs initialization.
 712  |        *
 713  |        *  This is the constructor provided by the standard.
 714  |        *
 715  |        *  @param __table If non-zero, table is used as the per-char mask.
 716  |        *               Else classic_table() is used.
 717  |        *  @param __del   If true, passes ownership of table to this facet.
 718  |        *  @param __refs  Passed to the base facet class.
 719  |       */
 720  |       explicit
 721  |       ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
 722  | 
 723  |       /**
 724  |        *  @brief  Constructor performs static initialization.
 725  |        *
 726  |        *  This constructor is used to construct the initial C locale facet.
 727  |        *
 728  |        *  @param __cloc  Handle to C locale data.
 729  |        *  @param __table If non-zero, table is used as the per-char mask.
 730  |        *  @param __del   If true, passes ownership of table to this facet.
 731  |        *  @param __refs  Passed to the base facet class.
 732  |       */
 733  |       explicit
 734  |       ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
 735  | 	    size_t __refs = 0);
 736  | 
 737  |       /**
 738  |        *  @brief  Test char classification.
 739  |        *
 740  |        *  This function compares the mask table[c] to @a __m.
 741  |        *
 742  |        *  @param __c  The char to compare the mask of.
 743  |        *  @param __m  The mask to compare against.
 744  |        *  @return  True if __m & table[__c] is true, false otherwise.
 745  |       */
 746  |       inline bool
 747  |       is(mask __m, char __c) const;
 748  | 
 749  |       /**
 750  |        *  @brief  Return a mask array.
 751  |        *
 752  |        *  This function finds the mask for each char in the range [lo, hi) and
 753  |        *  successively writes it to vec.  vec must have as many elements as
 754  |        *  the char array.
 755  |        *
 756  |        *  @param __lo  Pointer to start of range.
 757  |        *  @param __hi  Pointer to end of range.
 758  |        *  @param __vec  Pointer to an array of mask storage.
 759  |        *  @return  @a __hi.
 760  |       */
 761  |       inline const char*
 762  |       is(const char* __lo, const char* __hi, mask* __vec) const;
 763  | 
 764  |       /**
 765  |        *  @brief  Find char matching a mask
 766  |        *
 767  |        *  This function searches for and returns the first char in [lo,hi) for
 768  |        *  which is(m,char) is true.
 769  |        *
 770  |        *  @param __m  The mask to compare against.
 771  |        *  @param __lo  Pointer to start of range.
 772  |        *  @param __hi  Pointer to end of range.
 773  |        *  @return  Pointer to a matching char if found, else @a __hi.
 774  |       */
 775  |       inline const char*
 776  |       scan_is(mask __m, const char* __lo, const char* __hi) const;
 777  | 
 778  |       /**
 779  |        *  @brief  Find char not matching a mask
 780  |        *
 781  |        *  This function searches for and returns a pointer to the first char
 782  |        *  in [__lo,__hi) for which is(m,char) is false.
 783  |        *
 784  |        *  @param __m  The mask to compare against.
 785  |        *  @param __lo  Pointer to start of range.
 786  |        *  @param __hi  Pointer to end of range.
 787  |        *  @return  Pointer to a non-matching char if found, else @a __hi.
 788  |       */
 789  |       inline const char*
 790  |       scan_not(mask __m, const char* __lo, const char* __hi) const;
 791  | 
 792  |       /**
 793  |        *  @brief  Convert to uppercase.
 794  |        *
 795  |        *  This function converts the char argument to uppercase if possible.
 796  |        *  If not possible (for example, '2'), returns the argument.
 797  |        *
 798  |        *  toupper() acts as if it returns ctype<char>::do_toupper(c).
 799  |        *  do_toupper() must always return the same result for the same input.
 800  |        *
 801  |        *  @param __c  The char to convert.
 802  |        *  @return  The uppercase char if convertible, else @a __c.
 803  |       */
 804  |       char_type
 805  |       toupper(char_type __c) const
 806  |       { return this->do_toupper(__c); }
 807  | 
 808  |       /**
 809  |        *  @brief  Convert array to uppercase.
 810  |        *
 811  |        *  This function converts each char in the range [__lo,__hi) to uppercase
 812  |        *  if possible.  Other chars remain untouched.
 813  |        *
 814  |        *  toupper() acts as if it returns ctype<char>:: do_toupper(__lo, __hi).
 815  |        *  do_toupper() must always return the same result for the same input.
 816  |        *
 817  |        *  @param __lo  Pointer to first char in range.
 818  |        *  @param __hi  Pointer to end of range.
 819  |        *  @return  @a __hi.
 820  |       */
 821  |       const char_type*
 822  |       toupper(char_type *__lo, const char_type* __hi) const
 823  |       { return this->do_toupper(__lo, __hi); }
 824  | 
 825  |       /**
 826  |        *  @brief  Convert to lowercase.
 827  |        *
 828  |        *  This function converts the char argument to lowercase if possible.
 829  |        *  If not possible (for example, '2'), returns the argument.
 830  |        *
 831  |        *  tolower() acts as if it returns ctype<char>::do_tolower(__c).
 832  |        *  do_tolower() must always return the same result for the same input.
 833  |        *
 834  |        *  @param __c  The char to convert.
 835  |        *  @return  The lowercase char if convertible, else @a __c.
 836  |       */
 837  |       char_type
 838  |       tolower(char_type __c) const
 839  |       { return this->do_tolower(__c); }
 840  | 
 841  |       /**
 842  |        *  @brief  Convert array to lowercase.
 843  |        *
 844  |        *  This function converts each char in the range [lo,hi) to lowercase
 845  |        *  if possible.  Other chars remain untouched.
 846  |        *
 847  |        *  tolower() acts as if it returns ctype<char>:: do_tolower(__lo, __hi).
 848  |        *  do_tolower() must always return the same result for the same input.
 849  |        *
 850  |        *  @param __lo  Pointer to first char in range.
 851  |        *  @param __hi  Pointer to end of range.
 852  |        *  @return  @a __hi.
 853  |       */
 854  |       const char_type*
 855  |       tolower(char_type* __lo, const char_type* __hi) const
 856  |       { return this->do_tolower(__lo, __hi); }
 857  | 
 858  |       /**
 859  |        *  @brief  Widen char
 860  |        *
 861  |        *  This function converts the char to char_type using the simplest
 862  |        *  reasonable transformation.  For an underived ctype<char> facet, the
 863  |        *  argument will be returned unchanged.
 864  |        *
 865  |        *  This function works as if it returns ctype<char>::do_widen(c).
 866  |        *  do_widen() must always return the same result for the same input.
 867  |        *
 868  |        *  Note: this is not what you want for codepage conversions.  See
 869  |        *  codecvt for that.
 870  |        *
 871  |        *  @param __c  The char to convert.
 872  |        *  @return  The converted character.
 873  |       */
 874  |       char_type
 875  |       widen(char __c) const
 876  |       {
 877  | 	if (_M_widen_ok)
 878  | 	  return _M_widen[static_cast<unsigned char>(__c)];
 879  | 	this->_M_widen_init();
 880  | 	return this->do_widen(__c);
 881  |       }
 882  | 
 883  |       /**
 884  |        *  @brief  Widen char array
 885  |        *
 886  |        *  This function converts each char in the input to char using the
 887  |        *  simplest reasonable transformation.  For an underived ctype<char>
 888  |        *  facet, the argument will be copied unchanged.
 889  |        *
 890  |        *  This function works as if it returns ctype<char>::do_widen(c).
 891  |        *  do_widen() must always return the same result for the same input.
 892  |        *
 893  |        *  Note: this is not what you want for codepage conversions.  See
 894  |        *  codecvt for that.
 895  |        *
 896  |        *  @param __lo  Pointer to first char in range.
 897  |        *  @param __hi  Pointer to end of range.
 898  |        *  @param __to  Pointer to the destination array.
 899  |        *  @return  @a __hi.
 900  |       */
 901  |       const char*
 902  |       widen(const char* __lo, const char* __hi, char_type* __to) const
 903  |       {
 904  | 	if (_M_widen_ok == 1)
 905  | 	  {
 906  | 	    if (__builtin_expect(__hi != __lo, true))
 907  | 	      __builtin_memcpy(__to, __lo, __hi - __lo);
 908  | 	    return __hi;
 909  | 	  }
 910  | 	if (!_M_widen_ok)
 911  | 	  _M_widen_init();
 912  | 	return this->do_widen(__lo, __hi, __to);
 913  |       }
 914  | 
 915  |       /**
 916  |        *  @brief  Narrow char
 917  |        *
 918  |        *  This function converts the char to char using the simplest
 919  |        *  reasonable transformation.  If the conversion fails, dfault is
 920  |        *  returned instead.  For an underived ctype<char> facet, @a c
 921  |        *  will be returned unchanged.
 922  |        *
 923  |        *  This function works as if it returns ctype<char>::do_narrow(c).
 924  |        *  do_narrow() must always return the same result for the same input.
 925  |        *
 926  |        *  Note: this is not what you want for codepage conversions.  See
 927  |        *  codecvt for that.
 928  |        *
 929  |        *  @param __c  The char to convert.
 930  |        *  @param __dfault  Char to return if conversion fails.
 931  |        *  @return  The converted character.
 932  |       */
 933  |       char
 934  |       narrow(char_type __c, char __dfault) const
 935  |       {
 936  | 	if (_M_narrow[static_cast<unsigned char>(__c)])
 937  | 	  return _M_narrow[static_cast<unsigned char>(__c)];
 938  | 	const char __t = do_narrow(__c, __dfault);
 939  | 	if (__t != __dfault)
 940  | 	  _M_narrow[static_cast<unsigned char>(__c)] = __t;
 941  | 	return __t;
 942  |       }
 943  | 
 944  |       /**
 945  |        *  @brief  Narrow char array
 946  |        *
 947  |        *  This function converts each char in the input to char using the
 948  |        *  simplest reasonable transformation and writes the results to the
 949  |        *  destination array.  For any char in the input that cannot be
 950  |        *  converted, @a dfault is used instead.  For an underived ctype<char>
 951  |        *  facet, the argument will be copied unchanged.
 952  |        *
 953  |        *  This function works as if it returns ctype<char>::do_narrow(lo, hi,
 954  |        *  dfault, to).  do_narrow() must always return the same result for the
 955  |        *  same input.
 956  |        *
 957  |        *  Note: this is not what you want for codepage conversions.  See
 958  |        *  codecvt for that.
 959  |        *
 960  |        *  @param __lo  Pointer to start of range.
 961  |        *  @param __hi  Pointer to end of range.
 962  |        *  @param __dfault  Char to use if conversion fails.
 963  |        *  @param __to  Pointer to the destination array.
 964  |        *  @return  @a __hi.
 965  |       */
 966  |       const char_type*
 967  |       narrow(const char_type* __lo, const char_type* __hi,
 968  | 	     char __dfault, char* __to) const
 969  |       {
 970  | 	if (__builtin_expect(_M_narrow_ok == 1, true))
 971  | 	  {
 972  | 	    if (__builtin_expect(__hi != __lo, true))
 973  | 	      __builtin_memcpy(__to, __lo, __hi - __lo);
 974  | 	    return __hi;
 975  | 	  }
 976  | 	if (!_M_narrow_ok)
 977  | 	  _M_narrow_init();
 978  | 	return this->do_narrow(__lo, __hi, __dfault, __to);
 979  |       }
 980  | 
 981  |       // _GLIBCXX_RESOLVE_LIB_DEFECTS
 982  |       // DR 695. ctype<char>::classic_table() not accessible.
 983  |       /// Returns a pointer to the mask table provided to the constructor, or
 984  |       /// the default from classic_table() if none was provided.
 985  |       const mask*
 986  |       table() const throw()
 987  |       { return _M_table; }
 988  | 
 989  |       /// Returns a pointer to the C locale mask table.
 990  |       static const mask*
 991  |       classic_table() throw();
 992  |     protected:
 993  | 
 994  |       /**
 995  |        *  @brief  Destructor.
 996  |        *
 997  |        *  This function deletes table() if @a del was true in the
 998  |        *  constructor.
 999  |       */
1000  |       virtual
1001  |       ~ctype();
1002  | 
1003  |       /**
1004  |        *  @brief  Convert to uppercase.
1005  |        *
1006  |        *  This virtual function converts the char argument to uppercase if
1007  |        *  possible.  If not possible (for example, '2'), returns the argument.
1008  |        *
1009  |        *  do_toupper() is a hook for a derived facet to change the behavior of
1010  |        *  uppercasing.  do_toupper() must always return the same result for
1011  |        *  the same input.
1012  |        *
1013  |        *  @param __c  The char to convert.
1014  |        *  @return  The uppercase char if convertible, else @a __c.
1015  |       */
1016  |       virtual char_type
1017  |       do_toupper(char_type __c) const;
1018  | 
1019  |       /**
1020  |        *  @brief  Convert array to uppercase.
1021  |        *
1022  |        *  This virtual function converts each char in the range [lo,hi) to
1023  |        *  uppercase if possible.  Other chars remain untouched.
1024  |        *
1025  |        *  do_toupper() is a hook for a derived facet to change the behavior of
1026  |        *  uppercasing.  do_toupper() must always return the same result for
1027  |        *  the same input.
1028  |        *
1029  |        *  @param __lo  Pointer to start of range.
1030  |        *  @param __hi  Pointer to end of range.
1031  |        *  @return  @a __hi.
1032  |       */
1033  |       virtual const char_type*
1034  |       do_toupper(char_type* __lo, const char_type* __hi) const;
1035  | 
1036  |       /**
1037  |        *  @brief  Convert to lowercase.
1038  |        *
1039  |        *  This virtual function converts the char argument to lowercase if
1040  |        *  possible.  If not possible (for example, '2'), returns the argument.
1041  |        *
1042  |        *  do_tolower() is a hook for a derived facet to change the behavior of
1043  |        *  lowercasing.  do_tolower() must always return the same result for
1044  |        *  the same input.
1045  |        *
1046  |        *  @param __c  The char to convert.
1047  |        *  @return  The lowercase char if convertible, else @a __c.
1048  |       */
1049  |       virtual char_type
1050  |       do_tolower(char_type __c) const;
1051  | 
1052  |       /**
1053  |        *  @brief  Convert array to lowercase.
1054  |        *
1055  |        *  This virtual function converts each char in the range [lo,hi) to
1056  |        *  lowercase if possible.  Other chars remain untouched.
1057  |        *
1058  |        *  do_tolower() is a hook for a derived facet to change the behavior of
1059  |        *  lowercasing.  do_tolower() must always return the same result for
1060  |        *  the same input.
1061  |        *
1062  |        *  @param __lo  Pointer to first char in range.
1063  |        *  @param __hi  Pointer to end of range.
1064  |        *  @return  @a __hi.
1065  |       */
1066  |       virtual const char_type*
1067  |       do_tolower(char_type* __lo, const char_type* __hi) const;
1068  | 
1069  |       /**
1070  |        *  @brief  Widen char
1071  |        *
1072  |        *  This virtual function converts the char to char using the simplest
1073  |        *  reasonable transformation.  For an underived ctype<char> facet, the
1074  |        *  argument will be returned unchanged.
1075  |        *
1076  |        *  do_widen() is a hook for a derived facet to change the behavior of
1077  |        *  widening.  do_widen() must always return the same result for the
1078  |        *  same input.
1079  |        *
1080  |        *  Note: this is not what you want for codepage conversions.  See
1081  |        *  codecvt for that.
1082  |        *
1083  |        *  @param __c  The char to convert.
1084  |        *  @return  The converted character.
1085  |       */
1086  |       virtual char_type
1087  |       do_widen(char __c) const
1088  |       { return __c; }
1089  | 
1090  |       /**
1091  |        *  @brief  Widen char array
1092  |        *
1093  |        *  This function converts each char in the range [lo,hi) to char using
1094  |        *  the simplest reasonable transformation.  For an underived
1095  |        *  ctype<char> facet, the argument will be copied unchanged.
1096  |        *
1097  |        *  do_widen() is a hook for a derived facet to change the behavior of
1098  |        *  widening.  do_widen() must always return the same result for the
1099  |        *  same input.
1100  |        *
1101  |        *  Note: this is not what you want for codepage conversions.  See
1102  |        *  codecvt for that.
1103  |        *
1104  |        *  @param __lo  Pointer to start of range.
1105  |        *  @param __hi  Pointer to end of range.
1106  |        *  @param __to  Pointer to the destination array.
1107  |        *  @return  @a __hi.
1108  |       */
1109  |       virtual const char*
1110  |       do_widen(const char* __lo, const char* __hi, char_type* __to) const
1111  |       {
1112  | 	if (__builtin_expect(__hi != __lo, true))
1113  | 	  __builtin_memcpy(__to, __lo, __hi - __lo);
1114  | 	return __hi;
1115  |       }
1116  | 
1117  |       /**
1118  |        *  @brief  Narrow char
1119  |        *
1120  |        *  This virtual function converts the char to char using the simplest
1121  |        *  reasonable transformation.  If the conversion fails, dfault is
1122  |        *  returned instead.  For an underived ctype<char> facet, @a c will be
1123  |        *  returned unchanged.
1124  |        *
1125  |        *  do_narrow() is a hook for a derived facet to change the behavior of
1126  |        *  narrowing.  do_narrow() must always return the same result for the
1127  |        *  same input.
1128  |        *
1129  |        *  Note: this is not what you want for codepage conversions.  See
1130  |        *  codecvt for that.
1131  |        *
1132  |        *  @param __c  The char to convert.
1133  |        *  @param __dfault  Char to return if conversion fails.
1134  |        *  @return  The converted char.
1135  |       */
1136  |       virtual char
1137  |       do_narrow(char_type __c, char __dfault __attribute__((__unused__))) const
1138  |       { return __c; }
1139  | 
1140  |       /**
1141  |        *  @brief  Narrow char array to char array
1142  |        *
1143  |        *  This virtual function converts each char in the range [lo,hi) to
1144  |        *  char using the simplest reasonable transformation and writes the
1145  |        *  results to the destination array.  For any char in the input that
1146  |        *  cannot be converted, @a dfault is used instead.  For an underived
1147  |        *  ctype<char> facet, the argument will be copied unchanged.
1148  |        *
1149  |        *  do_narrow() is a hook for a derived facet to change the behavior of
1150  |        *  narrowing.  do_narrow() must always return the same result for the
1151  |        *  same input.
1152  |        *
1153  |        *  Note: this is not what you want for codepage conversions.  See
1154  |        *  codecvt for that.
1155  |        *
1156  |        *  @param __lo  Pointer to start of range.
1157  |        *  @param __hi  Pointer to end of range.
1158  |        *  @param __dfault  Char to use if conversion fails.
1159  |        *  @param __to  Pointer to the destination array.
1160  |        *  @return  @a __hi.
1161  |       */
1162  |       virtual const char_type*
1163  |       do_narrow(const char_type* __lo, const char_type* __hi,
1164  | 		char __dfault __attribute__((__unused__)), char* __to) const
1165  |       {
1166  | 	if (__builtin_expect(__hi != __lo, true))
1167  | 	  __builtin_memcpy(__to, __lo, __hi - __lo);
1168  | 	return __hi;
1169  |       }
1170  | 
1171  |     private:
1172  |       void _M_narrow_init() const;
1173  |       void _M_widen_init() const;
1174  |     };
1175  | 
1176  | #ifdef _GLIBCXX_USE_WCHAR_T
1177  |   /**
1178  |    *  @brief  The ctype<wchar_t> specialization.
1179  |    *  @ingroup locales
1180  |    *
1181  |    *  This class defines classification and conversion functions for the
1182  |    *  wchar_t type.  It gets used by wchar_t streams for many I/O operations.
1183  |    *  The wchar_t specialization provides a number of optimizations as well.
1184  |    *
1185  |    *  ctype<wchar_t> inherits its public methods from
1186  |    *  __ctype_abstract_base<wchar_t>.
1187  |   */
1188  |   template<>
1189  |     class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
1190  |     {
1191  |     public:
1192  |       // Types:
1193  |       /// Typedef for the template parameter wchar_t.
1194  |       typedef wchar_t		char_type;
1195  |       typedef wctype_t		__wmask_type;
1196  | 
1197  |     protected:
1198  |       __c_locale		_M_c_locale_ctype;
1199  | 
1200  |       // Pre-computed narrowed and widened chars.
1201  |       bool                      _M_narrow_ok;
1202  |       char                      _M_narrow[128];
1203  |       wint_t                    _M_widen[1 + static_cast<unsigned char>(-1)];
1204  | 
1205  |       // Pre-computed elements for do_is.
1206  |       mask                      _M_bit[16];
1207  |       __wmask_type              _M_wmask[16];
1208  | 
1209  |     public:
1210  |       // Data Members:
1211  |       /// The facet id for ctype<wchar_t>
1212  |       static locale::id		id;
1213  | 
1214  |       /**
1215  |        *  @brief  Constructor performs initialization.
1216  |        *
1217  |        *  This is the constructor provided by the standard.
1218  |        *
1219  |        *  @param __refs  Passed to the base facet class.
1220  |       */
1221  |       explicit
1222  |       ctype(size_t __refs = 0);
1223  | 
1224  |       /**
1225  |        *  @brief  Constructor performs static initialization.
1226  |        *
1227  |        *  This constructor is used to construct the initial C locale facet.
1228  |        *
1229  |        *  @param __cloc  Handle to C locale data.
1230  |        *  @param __refs  Passed to the base facet class.
1231  |       */
1232  |       explicit
1233  |       ctype(__c_locale __cloc, size_t __refs = 0);
1234  | 
1235  |     protected:
1236  |       __wmask_type
1237  |       _M_convert_to_wmask(const mask __m) const throw();
1238  | 
1239  |       /// Destructor
1240  |       virtual
1241  |       ~ctype();
1242  | 
1243  |       /**
1244  |        *  @brief  Test wchar_t classification.
1245  |        *
1246  |        *  This function finds a mask M for @a c and compares it to mask @a m.
1247  |        *
1248  |        *  do_is() is a hook for a derived facet to change the behavior of
1249  |        *  classifying.  do_is() must always return the same result for the
1250  |        *  same input.
1251  |        *
1252  |        *  @param __c  The wchar_t to find the mask of.
1253  |        *  @param __m  The mask to compare against.
1254  |        *  @return  (M & __m) != 0.
1255  |       */
1256  |       virtual bool
1257  |       do_is(mask __m, char_type __c) const;
1258  | 
1259  |       /**
1260  |        *  @brief  Return a mask array.
1261  |        *
1262  |        *  This function finds the mask for each wchar_t in the range [lo,hi)
1263  |        *  and successively writes it to vec.  vec must have as many elements
1264  |        *  as the input.
1265  |        *
1266  |        *  do_is() is a hook for a derived facet to change the behavior of
1267  |        *  classifying.  do_is() must always return the same result for the
1268  |        *  same input.
1269  |        *
1270  |        *  @param __lo  Pointer to start of range.
1271  |        *  @param __hi  Pointer to end of range.
1272  |        *  @param __vec  Pointer to an array of mask storage.
1273  |        *  @return  @a __hi.
1274  |       */
1275  |       virtual const char_type*
1276  |       do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
1277  | 
1278  |       /**
1279  |        *  @brief  Find wchar_t matching mask
1280  |        *
1281  |        *  This function searches for and returns the first wchar_t c in
1282  |        *  [__lo,__hi) for which is(__m,c) is true.
1283  |        *
1284  |        *  do_scan_is() is a hook for a derived facet to change the behavior of
1285  |        *  match searching.  do_is() must always return the same result for the
1286  |        *  same input.
1287  |        *
1288  |        *  @param __m  The mask to compare against.
1289  |        *  @param __lo  Pointer to start of range.
1290  |        *  @param __hi  Pointer to end of range.
1291  |        *  @return  Pointer to a matching wchar_t if found, else @a __hi.
1292  |       */
1293  |       virtual const char_type*
1294  |       do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
1295  | 
1296  |       /**
1297  |        *  @brief  Find wchar_t not matching mask
1298  |        *
1299  |        *  This function searches for and returns a pointer to the first
1300  |        *  wchar_t c of [__lo,__hi) for which is(__m,c) is false.
1301  |        *
1302  |        *  do_scan_is() is a hook for a derived facet to change the behavior of
1303  |        *  match searching.  do_is() must always return the same result for the
1304  |        *  same input.
1305  |        *
1306  |        *  @param __m  The mask to compare against.
1307  |        *  @param __lo  Pointer to start of range.
1308  |        *  @param __hi  Pointer to end of range.
1309  |        *  @return  Pointer to a non-matching wchar_t if found, else @a __hi.
1310  |       */
1311  |       virtual const char_type*
1312  |       do_scan_not(mask __m, const char_type* __lo,
1313  | 		  const char_type* __hi) const;
1314  | 
1315  |       /**
1316  |        *  @brief  Convert to uppercase.
1317  |        *
1318  |        *  This virtual function converts the wchar_t argument to uppercase if
1319  |        *  possible.  If not possible (for example, '2'), returns the argument.
1320  |        *
1321  |        *  do_toupper() is a hook for a derived facet to change the behavior of
1322  |        *  uppercasing.  do_toupper() must always return the same result for
1323  |        *  the same input.
1324  |        *
1325  |        *  @param __c  The wchar_t to convert.
1326  |        *  @return  The uppercase wchar_t if convertible, else @a __c.
1327  |       */
1328  |       virtual char_type
1329  |       do_toupper(char_type __c) const;
1330  | 
1331  |       /**
1332  |        *  @brief  Convert array to uppercase.
1333  |        *
1334  |        *  This virtual function converts each wchar_t in the range [lo,hi) to
1335  |        *  uppercase if possible.  Other elements remain untouched.
1336  |        *
1337  |        *  do_toupper() is a hook for a derived facet to change the behavior of
1338  |        *  uppercasing.  do_toupper() must always return the same result for
1339  |        *  the same input.
1340  |        *
1341  |        *  @param __lo  Pointer to start of range.
1342  |        *  @param __hi  Pointer to end of range.
1343  |        *  @return  @a __hi.
1344  |       */
1345  |       virtual const char_type*
1346  |       do_toupper(char_type* __lo, const char_type* __hi) const;
1347  | 
1348  |       /**
1349  |        *  @brief  Convert to lowercase.
1350  |        *
1351  |        *  This virtual function converts the argument to lowercase if
1352  |        *  possible.  If not possible (for example, '2'), returns the argument.
1353  |        *
1354  |        *  do_tolower() is a hook for a derived facet to change the behavior of
1355  |        *  lowercasing.  do_tolower() must always return the same result for
1356  |        *  the same input.
1357  |        *
1358  |        *  @param __c  The wchar_t to convert.
1359  |        *  @return  The lowercase wchar_t if convertible, else @a __c.
1360  |       */
1361  |       virtual char_type
1362  |       do_tolower(char_type __c) const;
1363  | 
1364  |       /**
1365  |        *  @brief  Convert array to lowercase.
1366  |        *
1367  |        *  This virtual function converts each wchar_t in the range [lo,hi) to
1368  |        *  lowercase if possible.  Other elements remain untouched.
1369  |        *
1370  |        *  do_tolower() is a hook for a derived facet to change the behavior of
1371  |        *  lowercasing.  do_tolower() must always return the same result for
1372  |        *  the same input.
1373  |        *
1374  |        *  @param __lo  Pointer to start of range.
1375  |        *  @param __hi  Pointer to end of range.
1376  |        *  @return  @a __hi.
1377  |       */
1378  |       virtual const char_type*
1379  |       do_tolower(char_type* __lo, const char_type* __hi) const;
1380  | 
1381  |       /**
1382  |        *  @brief  Widen char to wchar_t
1383  |        *
1384  |        *  This virtual function converts the char to wchar_t using the
1385  |        *  simplest reasonable transformation.  For an underived ctype<wchar_t>
1386  |        *  facet, the argument will be cast to wchar_t.
1387  |        *
1388  |        *  do_widen() is a hook for a derived facet to change the behavior of
1389  |        *  widening.  do_widen() must always return the same result for the
1390  |        *  same input.
1391  |        *
1392  |        *  Note: this is not what you want for codepage conversions.  See
1393  |        *  codecvt for that.
1394  |        *
1395  |        *  @param __c  The char to convert.
1396  |        *  @return  The converted wchar_t.
1397  |       */
1398  |       virtual char_type
1399  |       do_widen(char __c) const;
1400  | 
1401  |       /**
1402  |        *  @brief  Widen char array to wchar_t array
1403  |        *
1404  |        *  This function converts each char in the input to wchar_t using the
1405  |        *  simplest reasonable transformation.  For an underived ctype<wchar_t>
1406  |        *  facet, the argument will be copied, casting each element to wchar_t.
1407  |        *
1408  |        *  do_widen() is a hook for a derived facet to change the behavior of
1409  |        *  widening.  do_widen() must always return the same result for the
1410  |        *  same input.
1411  |        *
1412  |        *  Note: this is not what you want for codepage conversions.  See
1413  |        *  codecvt for that.
1414  |        *
1415  |        *  @param __lo  Pointer to start range.
1416  |        *  @param __hi  Pointer to end of range.
1417  |        *  @param __to  Pointer to the destination array.
1418  |        *  @return  @a __hi.
1419  |       */
1420  |       virtual const char*
1421  |       do_widen(const char* __lo, const char* __hi, char_type* __to) const;
1422  | 
1423  |       /**
1424  |        *  @brief  Narrow wchar_t to char
1425  |        *
1426  |        *  This virtual function converts the argument to char using
1427  |        *  the simplest reasonable transformation.  If the conversion
1428  |        *  fails, dfault is returned instead.  For an underived
1429  |        *  ctype<wchar_t> facet, @a c will be cast to char and
1430  |        *  returned.
1431  |        *
1432  |        *  do_narrow() is a hook for a derived facet to change the
1433  |        *  behavior of narrowing.  do_narrow() must always return the
1434  |        *  same result for the same input.
1435  |        *
1436  |        *  Note: this is not what you want for codepage conversions.  See
1437  |        *  codecvt for that.
1438  |        *
1439  |        *  @param __c  The wchar_t to convert.
1440  |        *  @param __dfault  Char to return if conversion fails.
1441  |        *  @return  The converted char.
1442  |       */
1443  |       virtual char
1444  |       do_narrow(char_type __c, char __dfault) const;
1445  | 
1446  |       /**
1447  |        *  @brief  Narrow wchar_t array to char array
1448  |        *
1449  |        *  This virtual function converts each wchar_t in the range [lo,hi) to
1450  |        *  char using the simplest reasonable transformation and writes the
1451  |        *  results to the destination array.  For any wchar_t in the input that
1452  |        *  cannot be converted, @a dfault is used instead.  For an underived
1453  |        *  ctype<wchar_t> facet, the argument will be copied, casting each
1454  |        *  element to char.
1455  |        *
1456  |        *  do_narrow() is a hook for a derived facet to change the behavior of
1457  |        *  narrowing.  do_narrow() must always return the same result for the
1458  |        *  same input.
1459  |        *
1460  |        *  Note: this is not what you want for codepage conversions.  See
1461  |        *  codecvt for that.
1462  |        *
1463  |        *  @param __lo  Pointer to start of range.
1464  |        *  @param __hi  Pointer to end of range.
1465  |        *  @param __dfault  Char to use if conversion fails.
1466  |        *  @param __to  Pointer to the destination array.
1467  |        *  @return  @a __hi.
1468  |       */
1469  |       virtual const char_type*
1470  |       do_narrow(const char_type* __lo, const char_type* __hi,
1471  | 		char __dfault, char* __to) const;
1472  | 
1473  |       // For use at construction time only.
1474  |       void
1475  |       _M_initialize_ctype() throw();
1476  |     };
1477  | #endif //_GLIBCXX_USE_WCHAR_T
1478  | 
1479  |   /// class ctype_byname [22.2.1.2].
1480  |   template<typename _CharT>
1481  |     class ctype_byname : public ctype<_CharT>
1482  |     {
1483  |     public:
1484  |       typedef typename ctype<_CharT>::mask  mask;
1485  | 
1486  |       explicit
1487  |       ctype_byname(const char* __s, size_t __refs = 0);
1488  | 
1489  | #if __cplusplus >= 201103L
1490  |       explicit
1491  |       ctype_byname(const string& __s, size_t __refs = 0)
1492  |       : ctype_byname(__s.c_str(), __refs) { }
1493  | #endif
1494  | 
1495  |     protected:
1496  |       virtual
1497  |       ~ctype_byname() { }
1498  |     };
1499  | 
1500  |   /// 22.2.1.4  Class ctype_byname specializations.
1501  |   template<>
1502  |     class ctype_byname<char> : public ctype<char>
1503  |     {
1504  |     public:
1505  |       explicit
1506  |       ctype_byname(const char* __s, size_t __refs = 0);
1507  | 
1508  | #if __cplusplus >= 201103L
1509  |       explicit
1510  |       ctype_byname(const string& __s, size_t __refs = 0);
1511  | #endif
1512  | 
1513  |     protected:
1514  |       virtual
1515  |       ~ctype_byname();
1516  |     };
1517  | 
1518  | #ifdef _GLIBCXX_USE_WCHAR_T
1519  |   template<>
1520  |     class ctype_byname<wchar_t> : public ctype<wchar_t>
1521  |     {
1522  |     public:
1523  |       explicit
1524  |       ctype_byname(const char* __s, size_t __refs = 0);
1525  | 
1526  | #if __cplusplus >= 201103L
1527  |       explicit
1528  |       ctype_byname(const string& __s, size_t __refs = 0);
1529  | #endif
1530  | 
1531  |     protected:
1532  |       virtual
1533  |       ~ctype_byname();
1534  |     };
1535  | #endif
1536  | 
1537  | _GLIBCXX_END_NAMESPACE_VERSION
1538  | } // namespace
1539  | 
1540  | // Include host and configuration specific ctype inlines.
1541  | #include <bits/ctype_inline.h>
1542  | 
1543  | namespace std _GLIBCXX_VISIBILITY(default)
1544  | {
1545  | _GLIBCXX_BEGIN_NAMESPACE_VERSION
1546  | 
1547  |   // 22.2.2  The numeric category.
1548  |   class __num_base
1549  |   {
1550  |   public:
1551  |     // NB: Code depends on the order of _S_atoms_out elements.
1552  |     // Below are the indices into _S_atoms_out.
1553  |     enum
1554  |       {
1555  | 	_S_ominus,
1556  | 	_S_oplus,
1557  | 	_S_ox,
1558  | 	_S_oX,
1559  | 	_S_odigits,
1560  | 	_S_odigits_end = _S_odigits + 16,
1561  | 	_S_oudigits = _S_odigits_end,
1562  | 	_S_oudigits_end = _S_oudigits + 16,
1563  | 	_S_oe = _S_odigits + 14,  // For scientific notation, 'e'
1564  | 	_S_oE = _S_oudigits + 14, // For scientific notation, 'E'
1565  | 	_S_oend = _S_oudigits_end
1566  |       };
1567  | 
1568  |     // A list of valid numeric literals for output.  This array
1569  |     // contains chars that will be passed through the current locale's
1570  |     // ctype<_CharT>.widen() and then used to render numbers.
1571  |     // For the standard "C" locale, this is
1572  |     // "-+xX0123456789abcdef0123456789ABCDEF".
1573  |     static const char* _S_atoms_out;
1574  | 
1575  |     // String literal of acceptable (narrow) input, for num_get.
1576  |     // "-+xX0123456789abcdefABCDEF"
1577  |     static const char* _S_atoms_in;
1578  | 
1579  |     enum
1580  |     {
1581  |       _S_iminus,
1582  |       _S_iplus,
1583  |       _S_ix,
1584  |       _S_iX,
1585  |       _S_izero,
1586  |       _S_ie = _S_izero + 14,
1587  |       _S_iE = _S_izero + 20,
1588  |       _S_iend = 26
1589  |     };
1590  | 
1591  |     // num_put
1592  |     // Construct and return valid scanf format for floating point types.
1593  |     static void
1594  |     _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
1595  |   };
1596  | 
1597  |   template<typename _CharT>
1598  |     struct __numpunct_cache : public locale::facet
1599  |     {
1600  |       const char*			_M_grouping;
1601  |       size_t                            _M_grouping_size;
1602  |       bool				_M_use_grouping;
1603  |       const _CharT*			_M_truename;
1604  |       size_t                            _M_truename_size;
1605  |       const _CharT*			_M_falsename;
1606  |       size_t                            _M_falsename_size;
1607  |       _CharT				_M_decimal_point;
1608  |       _CharT				_M_thousands_sep;
1609  | 
1610  |       // A list of valid numeric literals for output: in the standard
1611  |       // "C" locale, this is "-+xX0123456789abcdef0123456789ABCDEF".
1612  |       // This array contains the chars after having been passed
1613  |       // through the current locale's ctype<_CharT>.widen().
1614  |       _CharT				_M_atoms_out[__num_base::_S_oend];
1615  | 
1616  |       // A list of valid numeric literals for input: in the standard
1617  |       // "C" locale, this is "-+xX0123456789abcdefABCDEF"
1618  |       // This array contains the chars after having been passed
1619  |       // through the current locale's ctype<_CharT>.widen().
1620  |       _CharT				_M_atoms_in[__num_base::_S_iend];
1621  | 
1622  |       bool				_M_allocated;
1623  | 
1624  |       __numpunct_cache(size_t __refs = 0)
1625  |       : facet(__refs), _M_grouping(0), _M_grouping_size(0),
1626  | 	_M_use_grouping(false),
1627  | 	_M_truename(0), _M_truename_size(0), _M_falsename(0),
1628  | 	_M_falsename_size(0), _M_decimal_point(_CharT()),
1629  | 	_M_thousands_sep(_CharT()), _M_allocated(false)
1630  | 	{ }
1631  | 
1632  |       ~__numpunct_cache();
1633  | 
1634  |       void
1635  |       _M_cache(const locale& __loc);
1636  | 
1637  |     private:
1638  |       __numpunct_cache&
1639  |       operator=(const __numpunct_cache&);
1640  | 
1641  |       explicit
1642  |       __numpunct_cache(const __numpunct_cache&);
1643  |     };
1644  | 
1645  |   template<typename _CharT>
1646  |     __numpunct_cache<_CharT>::~__numpunct_cache()
1647  |     {
1648  |       if (_M_allocated)
1649  | 	{
1650  | 	  delete [] _M_grouping;
1651  | 	  delete [] _M_truename;
1652  | 	  delete [] _M_falsename;
1653  | 	}
1654  |     }
1655  | 
1656  | _GLIBCXX_BEGIN_NAMESPACE_CXX11
1657  | 
1658  |   /**
1659  |    *  @brief  Primary class template numpunct.
1660  |    *  @ingroup locales
1661  |    *
1662  |    *  This facet stores several pieces of information related to printing and
1663  |    *  scanning numbers, such as the decimal point character.  It takes a
1664  |    *  template parameter specifying the char type.  The numpunct facet is
1665  |    *  used by streams for many I/O operations involving numbers.
1666  |    *
1667  |    *  The numpunct template uses protected virtual functions to provide the
1668  |    *  actual results.  The public accessors forward the call to the virtual
1669  |    *  functions.  These virtual functions are hooks for developers to
1670  |    *  implement the behavior they require from a numpunct facet.
1671  |   */
1672  |   template<typename _CharT>
1673  |     class numpunct : public locale::facet
1674  |     {
1675  |     public:
1676  |       // Types:
1677  |       ///@{
1678  |       /// Public typedefs
1679  |       typedef _CharT			char_type;
1680  |       typedef basic_string<_CharT>	string_type;
1681  |       ///@}
1682  |       typedef __numpunct_cache<_CharT>  __cache_type;
1683  | 
1684  |     protected:
1685  |       __cache_type*			_M_data;
1686  | 
1687  |     public:
1688  |       /// Numpunct facet id.
1689  |       static locale::id			id;
1690  | 
1691  |       /**
1692  |        *  @brief  Numpunct constructor.
1693  |        *
1694  |        *  @param  __refs  Refcount to pass to the base class.
1695  |        */
1696  |       explicit
1697  |       numpunct(size_t __refs = 0)
1698  |       : facet(__refs), _M_data(0)
1699  |       { _M_initialize_numpunct(); }
1700  | 
1701  |       /**
1702  |        *  @brief  Internal constructor.  Not for general use.
1703  |        *
1704  |        *  This is a constructor for use by the library itself to set up the
1705  |        *  predefined locale facets.
1706  |        *
1707  |        *  @param  __cache  __numpunct_cache object.
1708  |        *  @param  __refs  Refcount to pass to the base class.
1709  |        */
1710  |       explicit
1711  |       numpunct(__cache_type* __cache, size_t __refs = 0)
1712  |       : facet(__refs), _M_data(__cache)
1713  |       { _M_initialize_numpunct(); }
1714  | 
1715  |       /**
1716  |        *  @brief  Internal constructor.  Not for general use.
1717  |        *
1718  |        *  This is a constructor for use by the library itself to set up new
1719  |        *  locales.
1720  |        *
1721  |        *  @param  __cloc  The C locale.
1722  |        *  @param  __refs  Refcount to pass to the base class.
1723  |        */
1724  |       explicit
1725  |       numpunct(__c_locale __cloc, size_t __refs = 0)
1726  |       : facet(__refs), _M_data(0)
1727  |       { _M_initialize_numpunct(__cloc); }
1728  | 
1729  |       /**
1730  |        *  @brief  Return decimal point character.
1731  |        *
1732  |        *  This function returns a char_type to use as a decimal point.  It
1733  |        *  does so by returning returning
1734  |        *  numpunct<char_type>::do_decimal_point().
1735  |        *
1736  |        *  @return  @a char_type representing a decimal point.
1737  |       */
1738  |       char_type
1739  |       decimal_point() const
1740  |       { return this->do_decimal_point(); }
1741  | 
1742  |       /**
1743  |        *  @brief  Return thousands separator character.
1744  |        *
1745  |        *  This function returns a char_type to use as a thousands
1746  |        *  separator.  It does so by returning returning
1747  |        *  numpunct<char_type>::do_thousands_sep().
1748  |        *
1749  |        *  @return  char_type representing a thousands separator.
1750  |       */
1751  |       char_type
1752  |       thousands_sep() const
1753  |       { return this->do_thousands_sep(); }
1754  | 
1755  |       /**
1756  |        *  @brief  Return grouping specification.
1757  |        *
1758  |        *  This function returns a string representing groupings for the
1759  |        *  integer part of a number.  Groupings indicate where thousands
1760  |        *  separators should be inserted in the integer part of a number.
1761  |        *
1762  |        *  Each char in the return string is interpret as an integer
1763  |        *  rather than a character.  These numbers represent the number
1764  |        *  of digits in a group.  The first char in the string
1765  |        *  represents the number of digits in the least significant
1766  |        *  group.  If a char is negative, it indicates an unlimited
1767  |        *  number of digits for the group.  If more chars from the
1768  |        *  string are required to group a number, the last char is used
1769  |        *  repeatedly.
1770  |        *
1771  |        *  For example, if the grouping() returns "\003\002" and is
1772  |        *  applied to the number 123456789, this corresponds to
1773  |        *  12,34,56,789.  Note that if the string was "32", this would
1774  |        *  put more than 50 digits into the least significant group if
1775  |        *  the character set is ASCII.
1776  |        *
1777  |        *  The string is returned by calling
1778  |        *  numpunct<char_type>::do_grouping().
1779  |        *
1780  |        *  @return  string representing grouping specification.
1781  |       */
1782  |       string
1783  |       grouping() const
1784  |       { return this->do_grouping(); }
1785  | 
1786  |       /**
1787  |        *  @brief  Return string representation of bool true.
1788  |        *
1789  |        *  This function returns a string_type containing the text
1790  |        *  representation for true bool variables.  It does so by calling
1791  |        *  numpunct<char_type>::do_truename().
1792  |        *
1793  |        *  @return  string_type representing printed form of true.
1794  |       */
1795  |       string_type
1796  |       truename() const
1797  |       { return this->do_truename(); }
1798  | 
1799  |       /**
1800  |        *  @brief  Return string representation of bool false.
1801  |        *
1802  |        *  This function returns a string_type containing the text
1803  |        *  representation for false bool variables.  It does so by calling
1804  |        *  numpunct<char_type>::do_falsename().
1805  |        *
1806  |        *  @return  string_type representing printed form of false.
1807  |       */
1808  |       string_type
1809  |       falsename() const
1810  |       { return this->do_falsename(); }
1811  | 
1812  |     protected:
1813  |       /// Destructor.
1814  |       virtual
1815  |       ~numpunct();
1816  | 
1817  |       /**
1818  |        *  @brief  Return decimal point character.
1819  |        *
1820  |        *  Returns a char_type to use as a decimal point.  This function is a
1821  |        *  hook for derived classes to change the value returned.
1822  |        *
1823  |        *  @return  @a char_type representing a decimal point.
1824  |       */
1825  |       virtual char_type
1826  |       do_decimal_point() const
1827  |       { return _M_data->_M_decimal_point; }
1828  | 
1829  |       /**
1830  |        *  @brief  Return thousands separator character.
1831  |        *
1832  |        *  Returns a char_type to use as a thousands separator.  This function
1833  |        *  is a hook for derived classes to change the value returned.
1834  |        *
1835  |        *  @return  @a char_type representing a thousands separator.
1836  |       */
1837  |       virtual char_type
1838  |       do_thousands_sep() const
1839  |       { return _M_data->_M_thousands_sep; }
1840  | 
1841  |       /**
1842  |        *  @brief  Return grouping specification.
1843  |        *
1844  |        *  Returns a string representing groupings for the integer part of a
1845  |        *  number.  This function is a hook for derived classes to change the
1846  |        *  value returned.  @see grouping() for details.
1847  |        *
1848  |        *  @return  String representing grouping specification.
1849  |       */
1850  |       virtual string
1851  |       do_grouping() const
1852  |       { return _M_data->_M_grouping; }
1853  | 
1854  |       /**
1855  |        *  @brief  Return string representation of bool true.
1856  |        *
1857  |        *  Returns a string_type containing the text representation for true
1858  |        *  bool variables.  This function is a hook for derived classes to
1859  |        *  change the value returned.
1860  |        *
1861  |        *  @return  string_type representing printed form of true.
1862  |       */
1863  |       virtual string_type
1864  |       do_truename() const
1865  |       { return _M_data->_M_truename; }
1866  | 
1867  |       /**
1868  |        *  @brief  Return string representation of bool false.
1869  |        *
1870  |        *  Returns a string_type containing the text representation for false
1871  |        *  bool variables.  This function is a hook for derived classes to
1872  |        *  change the value returned.
1873  |        *
1874  |        *  @return  string_type representing printed form of false.
1875  |       */
1876  |       virtual string_type
1877  |       do_falsename() const
1878  |       { return _M_data->_M_falsename; }
1879  | 
1880  |       // For use at construction time only.
1881  |       void
1882  |       _M_initialize_numpunct(__c_locale __cloc = 0);
1883  |     };
1884  | 
1885  |   template<typename _CharT>
1886  |     locale::id numpunct<_CharT>::id;
1887  | 
1888  |   template<>
1889  |     numpunct<char>::~numpunct();
1890  | 
1891  |   template<>
1892  |     void
1893  |     numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);
1894  | 
1895  | #ifdef _GLIBCXX_USE_WCHAR_T
1896  |   template<>
1897  |     numpunct<wchar_t>::~numpunct();
1898  | 
1899  |   template<>
1900  |     void
1901  |     numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);
1902  | #endif
1903  | 
1904  |   /// class numpunct_byname [22.2.3.2].
1905  |   template<typename _CharT>
1906  |     class numpunct_byname : public numpunct<_CharT>
1907  |     {
1908  |     public:
1909  |       typedef _CharT			char_type;
1910  |       typedef basic_string<_CharT>	string_type;
1911  | 
1912  |       explicit
1913  |       numpunct_byname(const char* __s, size_t __refs = 0)
1914  |       : numpunct<_CharT>(__refs)
1915  |       {
1916  | 	if (__builtin_strcmp(__s, "C") != 0
1917  | 	    && __builtin_strcmp(__s, "POSIX") != 0)
1918  | 	  {
1919  | 	    __c_locale __tmp;
1920  | 	    this->_S_create_c_locale(__tmp, __s);
1921  | 	    this->_M_initialize_numpunct(__tmp);
1922  | 	    this->_S_destroy_c_locale(__tmp);
1923  | 	  }
1924  |       }
1925  | 
1926  | #if __cplusplus >= 201103L
1927  |       explicit
1928  |       numpunct_byname(const string& __s, size_t __refs = 0)
1929  |       : numpunct_byname(__s.c_str(), __refs) { }
1930  | #endif
1931  | 
1932  |     protected:
1933  |       virtual
1934  |       ~numpunct_byname() { }
1935  |     };
1936  | 
1937  | _GLIBCXX_END_NAMESPACE_CXX11
1938  | 
1939  | _GLIBCXX_BEGIN_NAMESPACE_LDBL
1940  | 
1941  |   /**
1942  |    *  @brief  Primary class template num_get.
1943  |    *  @ingroup locales
1944  |    *
1945  |    *  This facet encapsulates the code to parse and return a number
1946  |    *  from a string.  It is used by the istream numeric extraction
1947  |    *  operators.
1948  |    *
1949  |    *  The num_get template uses protected virtual functions to provide the
1950  |    *  actual results.  The public accessors forward the call to the virtual
1951  |    *  functions.  These virtual functions are hooks for developers to
1952  |    *  implement the behavior they require from the num_get facet.
1953  |   */
1954  |   template<typename _CharT, typename _InIter>
1955  |     class num_get : public locale::facet
1956  |     {
1957  |     public:
1958  |       // Types:
1959  |       ///@{
1960  |       /// Public typedefs
1961  |       typedef _CharT			char_type;
1962  |       typedef _InIter			iter_type;
1963  |       ///@}
1964  | 
1965  |       /// Numpunct facet id.
1966  |       static locale::id			id;
1967  | 
1968  |       /**
1969  |        *  @brief  Constructor performs initialization.
1970  |        *
1971  |        *  This is the constructor provided by the standard.
1972  |        *
1973  |        *  @param __refs  Passed to the base facet class.
1974  |       */
1975  |       explicit
1976  |       num_get(size_t __refs = 0) : facet(__refs) { }
1977  | 
1978  |       /**
1979  |        *  @brief  Numeric parsing.
1980  |        *
1981  |        *  Parses the input stream into the bool @a v.  It does so by calling
1982  |        *  num_get::do_get().
1983  |        *
1984  |        *  If ios_base::boolalpha is set, attempts to read
1985  |        *  ctype<CharT>::truename() or ctype<CharT>::falsename().  Sets
1986  |        *  @a v to true or false if successful.  Sets err to
1987  |        *  ios_base::failbit if reading the string fails.  Sets err to
1988  |        *  ios_base::eofbit if the stream is emptied.
1989  |        *
1990  |        *  If ios_base::boolalpha is not set, proceeds as with reading a long,
1991  |        *  except if the value is 1, sets @a v to true, if the value is 0, sets
1992  |        *  @a v to false, and otherwise set err to ios_base::failbit.
1993  |        *
1994  |        *  @param  __in  Start of input stream.
1995  |        *  @param  __end  End of input stream.
1996  |        *  @param  __io  Source of locale and flags.
1997  |        *  @param  __err  Error flags to set.
1998  |        *  @param  __v  Value to format and insert.
1999  |        *  @return  Iterator after reading.
2000  |       */
2001  |       iter_type
2002  |       get(iter_type __in, iter_type __end, ios_base& __io,
2003  | 	  ios_base::iostate& __err, bool& __v) const
2004  |       { return this->do_get(__in, __end, __io, __err, __v); }
2005  | 
2006  |       ///@{
2007  |       /**
2008  |        *  @brief  Numeric parsing.
2009  |        *
2010  |        *  Parses the input stream into the integral variable @a v.  It does so
2011  |        *  by calling num_get::do_get().
2012  |        *
2013  |        *  Parsing is affected by the flag settings in @a io.
2014  |        *
2015  |        *  The basic parse is affected by the value of io.flags() &
2016  |        *  ios_base::basefield.  If equal to ios_base::oct, parses like the
2017  |        *  scanf %o specifier.  Else if equal to ios_base::hex, parses like %X
2018  |        *  specifier.  Else if basefield equal to 0, parses like the %i
2019  |        *  specifier.  Otherwise, parses like %d for signed and %u for unsigned
2020  |        *  types.  The matching type length modifier is also used.
2021  |        *
2022  |        *  Digit grouping is interpreted according to
2023  |        *  numpunct::grouping() and numpunct::thousands_sep().  If the
2024  |        *  pattern of digit groups isn't consistent, sets err to
2025  |        *  ios_base::failbit.
2026  |        *
2027  |        *  If parsing the string yields a valid value for @a v, @a v is set.
2028  |        *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
2029  |        *  Sets err to ios_base::eofbit if the stream is emptied.
2030  |        *
2031  |        *  @param  __in  Start of input stream.
2032  |        *  @param  __end  End of input stream.
2033  |        *  @param  __io  Source of locale and flags.
2034  |        *  @param  __err  Error flags to set.
2035  |        *  @param  __v  Value to format and insert.
2036  |        *  @return  Iterator after reading.
2037  |       */
2038  |       iter_type
2039  |       get(iter_type __in, iter_type __end, ios_base& __io,
2040  | 	  ios_base::iostate& __err, long& __v) const
2041  |       { return this->do_get(__in, __end, __io, __err, __v); }
2042  | 
2043  |       iter_type
2044  |       get(iter_type __in, iter_type __end, ios_base& __io,
2045  | 	  ios_base::iostate& __err, unsigned short& __v) const
2046  |       { return this->do_get(__in, __end, __io, __err, __v); }
2047  | 
2048  |       iter_type
2049  |       get(iter_type __in, iter_type __end, ios_base& __io,
2050  | 	  ios_base::iostate& __err, unsigned int& __v)   const
2051  |       { return this->do_get(__in, __end, __io, __err, __v); }
2052  | 
2053  |       iter_type
2054  |       get(iter_type __in, iter_type __end, ios_base& __io,
2055  | 	  ios_base::iostate& __err, unsigned long& __v)  const
2056  |       { return this->do_get(__in, __end, __io, __err, __v); }
2057  | 
2058  | #ifdef _GLIBCXX_USE_LONG_LONG
2059  |       iter_type
2060  |       get(iter_type __in, iter_type __end, ios_base& __io,
2061  | 	  ios_base::iostate& __err, long long& __v) const
2062  |       { return this->do_get(__in, __end, __io, __err, __v); }
2063  | 
2064  |       iter_type
2065  |       get(iter_type __in, iter_type __end, ios_base& __io,
2066  | 	  ios_base::iostate& __err, unsigned long long& __v)  const
2067  |       { return this->do_get(__in, __end, __io, __err, __v); }
2068  | #endif
2069  |       ///@}
2070  | 
2071  |       ///@{
2072  |       /**
2073  |        *  @brief  Numeric parsing.
2074  |        *
2075  |        *  Parses the input stream into the integral variable @a v.  It does so
2076  |        *  by calling num_get::do_get().
2077  |        *
2078  |        *  The input characters are parsed like the scanf %g specifier.  The
2079  |        *  matching type length modifier is also used.
2080  |        *
2081  |        *  The decimal point character used is numpunct::decimal_point().
2082  |        *  Digit grouping is interpreted according to
2083  |        *  numpunct::grouping() and numpunct::thousands_sep().  If the
2084  |        *  pattern of digit groups isn't consistent, sets err to
2085  |        *  ios_base::failbit.
2086  |        *
2087  |        *  If parsing the string yields a valid value for @a v, @a v is set.
2088  |        *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
2089  |        *  Sets err to ios_base::eofbit if the stream is emptied.
2090  |        *
2091  |        *  @param  __in  Start of input stream.
2092  |        *  @param  __end  End of input stream.
2093  |        *  @param  __io  Source of locale and flags.
2094  |        *  @param  __err  Error flags to set.
2095  |        *  @param  __v  Value to format and insert.
2096  |        *  @return  Iterator after reading.
2097  |       */
2098  |       iter_type
2099  |       get(iter_type __in, iter_type __end, ios_base& __io,
2100  | 	  ios_base::iostate& __err, float& __v) const
2101  |       { return this->do_get(__in, __end, __io, __err, __v); }
2102  | 
2103  |       iter_type
2104  |       get(iter_type __in, iter_type __end, ios_base& __io,
2105  | 	  ios_base::iostate& __err, double& __v) const
2106  |       { return this->do_get(__in, __end, __io, __err, __v); }
2107  | 
2108  |       iter_type
2109  |       get(iter_type __in, iter_type __end, ios_base& __io,
2110  | 	  ios_base::iostate& __err, long double& __v) const
2111  |       { return this->do_get(__in, __end, __io, __err, __v); }
2112  |       ///@}
2113  | 
2114  |       /**
2115  |        *  @brief  Numeric parsing.
2116  |        *
2117  |        *  Parses the input stream into the pointer variable @a v.  It does so
2118  |        *  by calling num_get::do_get().
2119  |        *
2120  |        *  The input characters are parsed like the scanf %p specifier.
2121  |        *
2122  |        *  Digit grouping is interpreted according to
2123  |        *  numpunct::grouping() and numpunct::thousands_sep().  If the
2124  |        *  pattern of digit groups isn't consistent, sets err to
2125  |        *  ios_base::failbit.
2126  |        *
2127  |        *  Note that the digit grouping effect for pointers is a bit ambiguous
2128  |        *  in the standard and shouldn't be relied on.  See DR 344.
2129  |        *
2130  |        *  If parsing the string yields a valid value for @a v, @a v is set.
2131  |        *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
2132  |        *  Sets err to ios_base::eofbit if the stream is emptied.
2133  |        *
2134  |        *  @param  __in  Start of input stream.
2135  |        *  @param  __end  End of input stream.
2136  |        *  @param  __io  Source of locale and flags.
2137  |        *  @param  __err  Error flags to set.
2138  |        *  @param  __v  Value to format and insert.
2139  |        *  @return  Iterator after reading.
2140  |       */
2141  |       iter_type
2142  |       get(iter_type __in, iter_type __end, ios_base& __io,
2143  | 	  ios_base::iostate& __err, void*& __v) const
2144  |       { return this->do_get(__in, __end, __io, __err, __v); }
2145  | 
2146  |     protected:
2147  |       /// Destructor.
2148  |       virtual ~num_get() { }
2149  | 
2150  |       _GLIBCXX_DEFAULT_ABI_TAG
2151  |       iter_type
2152  |       _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
2153  | 		       string&) const;
2154  | 
2155  |       template<typename _ValueT>
2156  | 	_GLIBCXX_DEFAULT_ABI_TAG
2157  | 	iter_type
2158  | 	_M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
2159  | 		       _ValueT&) const;
2160  | 
2161  |       template<typename _CharT2>
2162  |       typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
2163  | 	_M_find(const _CharT2*, size_t __len, _CharT2 __c) const
2164  | 	{
2165  | 	  int __ret = -1;
2166  | 	  if (__len <= 10)
2167  | 	    {
2168  | 	      if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
2169  | 		__ret = __c - _CharT2('0');
2170  | 	    }
2171  | 	  else
2172  | 	    {
2173  | 	      if (__c >= _CharT2('0') && __c <= _CharT2('9'))
2174  | 		__ret = __c - _CharT2('0');
2175  | 	      else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
2176  | 		__ret = 10 + (__c - _CharT2('a'));
2177  | 	      else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
2178  | 		__ret = 10 + (__c - _CharT2('A'));
2179  | 	    }
2180  | 	  return __ret;
2181  | 	}
2182  | 
2183  |       template<typename _CharT2>
2184  |       typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
2185  | 				      int>::__type
2186  | 	_M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
2187  | 	{
2188  | 	  int __ret = -1;
2189  | 	  const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
2190  | 	  if (__q)
2191  | 	    {
2192  | 	      __ret = __q - __zero;
2193  | 	      if (__ret > 15)
2194  | 		__ret -= 6;
2195  | 	    }
2196  | 	  return __ret;
2197  | 	}
2198  | 
2199  |       ///@{
2200  |       /**
2201  |        *  @brief  Numeric parsing.
2202  |        *
2203  |        *  Parses the input stream into the variable @a v.  This function is a
2204  |        *  hook for derived classes to change the value returned.  @see get()
2205  |        *  for more details.
2206  |        *
2207  |        *  @param  __beg  Start of input stream.
2208  |        *  @param  __end  End of input stream.
2209  |        *  @param  __io  Source of locale and flags.
2210  |        *  @param  __err  Error flags to set.
2211  |        *  @param  __v  Value to format and insert.
2212  |        *  @return  Iterator after reading.
2213  |       */
2214  |       virtual iter_type
2215  |       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;
2216  | 
2217  |       virtual iter_type
2218  |       do_get(iter_type __beg, iter_type __end, ios_base& __io,
2219  | 	     ios_base::iostate& __err, long& __v) const
2220  |       { return _M_extract_int(__beg, __end, __io, __err, __v); }
2221  | 
2222  |       virtual iter_type
2223  |       do_get(iter_type __beg, iter_type __end, ios_base& __io,
2224  | 	     ios_base::iostate& __err, unsigned short& __v) const
2225  |       { return _M_extract_int(__beg, __end, __io, __err, __v); }
2226  | 
2227  |       virtual iter_type
2228  |       do_get(iter_type __beg, iter_type __end, ios_base& __io,
2229  | 	     ios_base::iostate& __err, unsigned int& __v) const
2230  |       { return _M_extract_int(__beg, __end, __io, __err, __v); }
2231  | 
2232  |       virtual iter_type
2233  |       do_get(iter_type __beg, iter_type __end, ios_base& __io,
2234  | 	     ios_base::iostate& __err, unsigned long& __v) const
2235  |       { return _M_extract_int(__beg, __end, __io, __err, __v); }
2236  | 
2237  | #ifdef _GLIBCXX_USE_LONG_LONG
2238  |       virtual iter_type
2239  |       do_get(iter_type __beg, iter_type __end, ios_base& __io,
2240  | 	     ios_base::iostate& __err, long long& __v) const
2241  |       { return _M_extract_int(__beg, __end, __io, __err, __v); }
2242  | 
2243  |       virtual iter_type
2244  |       do_get(iter_type __beg, iter_type __end, ios_base& __io,
2245  | 	     ios_base::iostate& __err, unsigned long long& __v) const
2246  |       { return _M_extract_int(__beg, __end, __io, __err, __v); }
2247  | #endif
2248  | 
2249  |       virtual iter_type
2250  |       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;
2251  | 
2252  |       virtual iter_type
2253  |       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
2254  | 	     double&) const;
2255  | 
2256  |       // XXX GLIBCXX_ABI Deprecated
2257  | #if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__
2258  |       // For __gnu_cxx_ldbl128::num_get and __gnu_cxx_ieee128::num_get
2259  |       // this entry in the vtable is for a 64-bit "long double" with the
2260  |       // same format as double. This keeps the vtable layout consistent
2261  |       // with std::num_get (visible when -mlong-double-64 is used).
2262  |       virtual iter_type
2263  |       __do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
2264  | 	       double&) const;
2265  | #else
2266  |       virtual iter_type
2267  |       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
2268  | 	     long double&) const;
2269  | #endif
2270  | 
2271  |       virtual iter_type
2272  |       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
2273  | 
2274  |       // XXX GLIBCXX_ABI Deprecated
2275  | #if defined _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT \
2276  |       && defined __LONG_DOUBLE_IEEE128__
2277  |       // For __gnu_cxx_ieee128::num_get this entry in the vtable is for
2278  |       // the non-IEEE 128-bit "long double" (aka "double double"). This
2279  |       // is consistent with __gnu_cxx_ldbl128::num_get (-mabi=ibmlongdouble)
2280  |       virtual iter_type
2281  |       __do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
2282  | 	       __ibm128&) const;
2283  | #endif
2284  | 
2285  |       // XXX GLIBCXX_ABI Deprecated
2286  | #if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__
2287  |       // For __gnu_cxx_ldbl128::num_get and __gnu_cxx_ieee128::num_get
2288  |       // this entry in the vtable is for the 128-bit "long double" type.
2289  |       virtual iter_type
2290  |       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
2291  | 	     long double&) const;
2292  | #endif
2293  |       ///@}
2294  |     };
2295  | 
2296  |   template<typename _CharT, typename _InIter>
2297  |     locale::id num_get<_CharT, _InIter>::id;
2298  | 
2299  | 
2300  |   /**
2301  |    *  @brief  Primary class template num_put.
2302  |    *  @ingroup locales
2303  |    *
2304  |    *  This facet encapsulates the code to convert a number to a string.  It is
2305  |    *  used by the ostream numeric insertion operators.
2306  |    *
2307  |    *  The num_put template uses protected virtual functions to provide the
2308  |    *  actual results.  The public accessors forward the call to the virtual
2309  |    *  functions.  These virtual functions are hooks for developers to
2310  |    *  implement the behavior they require from the num_put facet.
2311  |   */
2312  |   template<typename _CharT, typename _OutIter>
2313  |     class num_put : public locale::facet
2314  |     {
2315  |     public:
2316  |       // Types:
2317  |       ///@{
2318  |       /// Public typedefs
2319  |       typedef _CharT		char_type;
2320  |       typedef _OutIter		iter_type;
2321  |       ///@}
2322  | 
2323  |       /// Numpunct facet id.
2324  |       static locale::id		id;
2325  | 
2326  |       /**
2327  |        *  @brief  Constructor performs initialization.
2328  |        *
2329  |        *  This is the constructor provided by the standard.
2330  |        *
2331  |        *  @param __refs  Passed to the base facet class.
2332  |       */
2333  |       explicit
2334  |       num_put(size_t __refs = 0) : facet(__refs) { }
2335  | 
2336  |       /**
2337  |        *  @brief  Numeric formatting.
2338  |        *
2339  |        *  Formats the boolean @a v and inserts it into a stream.  It does so
2340  |        *  by calling num_put::do_put().
2341  |        *
2342  |        *  If ios_base::boolalpha is set, writes ctype<CharT>::truename() or
2343  |        *  ctype<CharT>::falsename().  Otherwise formats @a v as an int.
2344  |        *
2345  |        *  @param  __s  Stream to write to.
2346  |        *  @param  __io  Source of locale and flags.
2347  |        *  @param  __fill  Char_type to use for filling.
2348  |        *  @param  __v  Value to format and insert.
2349  |        *  @return  Iterator after writing.
2350  |       */
2351  |       iter_type
2352  |       put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
2353  |       { return this->do_put(__s, __io, __fill, __v); }
2354  | 
2355  |       ///@{
2356  |       /**
2357  |        *  @brief  Numeric formatting.
2358  |        *
2359  |        *  Formats the integral value @a v and inserts it into a
2360  |        *  stream.  It does so by calling num_put::do_put().
2361  |        *
2362  |        *  Formatting is affected by the flag settings in @a io.
2363  |        *
2364  |        *  The basic format is affected by the value of io.flags() &
2365  |        *  ios_base::basefield.  If equal to ios_base::oct, formats like the
2366  |        *  printf %o specifier.  Else if equal to ios_base::hex, formats like
2367  |        *  %x or %X with ios_base::uppercase unset or set respectively.
2368  |        *  Otherwise, formats like %d, %ld, %lld for signed and %u, %lu, %llu
2369  |        *  for unsigned values.  Note that if both oct and hex are set, neither
2370  |        *  will take effect.
2371  |        *
2372  |        *  If ios_base::showpos is set, '+' is output before positive values.
2373  |        *  If ios_base::showbase is set, '0' precedes octal values (except 0)
2374  |        *  and '0[xX]' precedes hex values.
2375  |        *
2376  |        *  The decimal point character used is numpunct::decimal_point().
2377  |        *  Thousands separators are inserted according to
2378  |        *  numpunct::grouping() and numpunct::thousands_sep().
2379  |        *
2380  |        *  If io.width() is non-zero, enough @a fill characters are inserted to
2381  |        *  make the result at least that wide.  If
2382  |        *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is
2383  |        *  padded at the end.  If ios_base::internal, then padding occurs
2384  |        *  immediately after either a '+' or '-' or after '0x' or '0X'.
2385  |        *  Otherwise, padding occurs at the beginning.
2386  |        *
2387  |        *  @param  __s  Stream to write to.
2388  |        *  @param  __io  Source of locale and flags.
2389  |        *  @param  __fill  Char_type to use for filling.
2390  |        *  @param  __v  Value to format and insert.
2391  |        *  @return  Iterator after writing.
2392  |       */
2393  |       iter_type
2394  |       put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
2395  |       { return this->do_put(__s, __io, __fill, __v); }
2396  | 
2397  |       iter_type
2398  |       put(iter_type __s, ios_base& __io, char_type __fill,
2399  | 	  unsigned long __v) const
2400  |       { return this->do_put(__s, __io, __fill, __v); }
2401  | 
2402  | #ifdef _GLIBCXX_USE_LONG_LONG
2403  |       iter_type
2404  |       put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
2405  |       { return this->do_put(__s, __io, __fill, __v); }
2406  | 
2407  |       iter_type
2408  |       put(iter_type __s, ios_base& __io, char_type __fill,
2409  | 	  unsigned long long __v) const
2410  |       { return this->do_put(__s, __io, __fill, __v); }
2411  | #endif
2412  |       ///@}
2413  | 
2414  |       ///@{
2415  |       /**
2416  |        *  @brief  Numeric formatting.
2417  |        *
2418  |        *  Formats the floating point value @a v and inserts it into a stream.
2419  |        *  It does so by calling num_put::do_put().
2420  |        *
2421  |        *  Formatting is affected by the flag settings in @a io.
2422  |        *
2423  |        *  The basic format is affected by the value of io.flags() &
2424  |        *  ios_base::floatfield.  If equal to ios_base::fixed, formats like the
2425  |        *  printf %f specifier.  Else if equal to ios_base::scientific, formats
2426  |        *  like %e or %E with ios_base::uppercase unset or set respectively.
2427  |        *  Otherwise, formats like %g or %G depending on uppercase.  Note that
2428  |        *  if both fixed and scientific are set, the effect will also be like
2429  |        *  %g or %G.
2430  |        *
2431  |        *  The output precision is given by io.precision().  This precision is
2432  |        *  capped at numeric_limits::digits10 + 2 (different for double and
2433  |        *  long double).  The default precision is 6.
2434  |        *
2435  |        *  If ios_base::showpos is set, '+' is output before positive values.
2436  |        *  If ios_base::showpoint is set, a decimal point will always be
2437  |        *  output.
2438  |        *
2439  |        *  The decimal point character used is numpunct::decimal_point().
2440  |        *  Thousands separators are inserted according to
2441  |        *  numpunct::grouping() and numpunct::thousands_sep().
2442  |        *
2443  |        *  If io.width() is non-zero, enough @a fill characters are inserted to
2444  |        *  make the result at least that wide.  If
2445  |        *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is
2446  |        *  padded at the end.  If ios_base::internal, then padding occurs
2447  |        *  immediately after either a '+' or '-' or after '0x' or '0X'.
2448  |        *  Otherwise, padding occurs at the beginning.
2449  |        *
2450  |        *  @param  __s  Stream to write to.
2451  |        *  @param  __io  Source of locale and flags.
2452  |        *  @param  __fill  Char_type to use for filling.
2453  |        *  @param  __v  Value to format and insert.
2454  |        *  @return  Iterator after writing.
2455  |       */
2456  |       iter_type
2457  |       put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
2458  |       { return this->do_put(__s, __io, __fill, __v); }
2459  | 
2460  |       iter_type
2461  |       put(iter_type __s, ios_base& __io, char_type __fill,
2462  | 	  long double __v) const
2463  |       { return this->do_put(__s, __io, __fill, __v); }
2464  |       ///@}
2465  | 
2466  |       /**
2467  |        *  @brief  Numeric formatting.
2468  |        *
2469  |        *  Formats the pointer value @a v and inserts it into a stream.  It
2470  |        *  does so by calling num_put::do_put().
2471  |        *
2472  |        *  This function formats @a v as an unsigned long with ios_base::hex
2473  |        *  and ios_base::showbase set.
2474  |        *
2475  |        *  @param  __s  Stream to write to.
2476  |        *  @param  __io  Source of locale and flags.
2477  |        *  @param  __fill  Char_type to use for filling.
2478  |        *  @param  __v  Value to format and insert.
2479  |        *  @return  Iterator after writing.
2480  |       */
2481  |       iter_type
2482  |       put(iter_type __s, ios_base& __io, char_type __fill,
2483  | 	  const void* __v) const
2484  |       { return this->do_put(__s, __io, __fill, __v); }
2485  | 
2486  |     protected:
2487  |       template<typename _ValueT>
2488  | 	iter_type
2489  | 	_M_insert_float(iter_type, ios_base& __io, char_type __fill,
2490  | 			char __mod, _ValueT __v) const;
2491  | 
2492  |       void
2493  |       _M_group_float(const char* __grouping, size_t __grouping_size,
2494  | 		     char_type __sep, const char_type* __p, char_type* __new,
2495  | 		     char_type* __cs, int& __len) const;
2496  | 
2497  |       template<typename _ValueT>
2498  | 	iter_type
2499  | 	_M_insert_int(iter_type, ios_base& __io, char_type __fill,
2500  | 		      _ValueT __v) const;
2501  | 
2502  |       void
2503  |       _M_group_int(const char* __grouping, size_t __grouping_size,
2504  | 		   char_type __sep, ios_base& __io, char_type* __new,
2505  | 		   char_type* __cs, int& __len) const;
2506  | 
2507  |       void
2508  |       _M_pad(char_type __fill, streamsize __w, ios_base& __io,
2509  | 	     char_type* __new, const char_type* __cs, int& __len) const;
2510  | 
2511  |       /// Destructor.
2512  |       virtual
2513  |       ~num_put() { }
2514  | 
2515  |       ///@{
2516  |       /**
2517  |        *  @brief  Numeric formatting.
2518  |        *
2519  |        *  These functions do the work of formatting numeric values and
2520  |        *  inserting them into a stream. This function is a hook for derived
2521  |        *  classes to change the value returned.
2522  |        *
2523  |        *  @param  __s  Stream to write to.
2524  |        *  @param  __io  Source of locale and flags.
2525  |        *  @param  __fill  Char_type to use for filling.
2526  |        *  @param  __v  Value to format and insert.
2527  |        *  @return  Iterator after writing.
2528  |       */
2529  |       virtual iter_type
2530  |       do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;
2531  | 
2532  |       virtual iter_type
2533  |       do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
2534  |       { return _M_insert_int(__s, __io, __fill, __v); }
2535  | 
2536  |       virtual iter_type
2537  |       do_put(iter_type __s, ios_base& __io, char_type __fill,
2538  | 	     unsigned long __v) const
2539  |       { return _M_insert_int(__s, __io, __fill, __v); }
2540  | 
2541  | #ifdef _GLIBCXX_USE_LONG_LONG
2542  |       virtual iter_type
2543  |       do_put(iter_type __s, ios_base& __io, char_type __fill,
2544  | 	     long long __v) const
2545  |       { return _M_insert_int(__s, __io, __fill, __v); }
2546  | 
2547  |       virtual iter_type
2548  |       do_put(iter_type __s, ios_base& __io, char_type __fill,
2549  | 	     unsigned long long __v) const
2550  |       { return _M_insert_int(__s, __io, __fill, __v); }
2551  | #endif
2552  | 
2553  |       virtual iter_type
2554  |       do_put(iter_type, ios_base&, char_type, double) const;
2555  | 
2556  |       // XXX GLIBCXX_ABI Deprecated
2557  | #if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__
2558  |       virtual iter_type
2559  |       __do_put(iter_type, ios_base&, char_type, double) const;
2560  | #else
2561  |       virtual iter_type
2562  |       do_put(iter_type, ios_base&, char_type, long double) const;
2563  | #endif
2564  | 
2565  |       virtual iter_type
2566  |       do_put(iter_type, ios_base&, char_type, const void*) const;
2567  | 
2568  |       // XXX GLIBCXX_ABI Deprecated
2569  | #if defined _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT \
2570  |       && defined __LONG_DOUBLE_IEEE128__
2571  |       virtual iter_type
2572  |       __do_put(iter_type, ios_base&, char_type, __ibm128) const;
2573  | #endif
2574  | 
2575  |       // XXX GLIBCXX_ABI Deprecated
2576  | #if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__
2577  |       virtual iter_type
2578  |       do_put(iter_type, ios_base&, char_type, long double) const;
2579  | #endif
2580  |       ///@}
2581  |     };
2582  | 
2583  |   template <typename _CharT, typename _OutIter>
2584  |     locale::id num_put<_CharT, _OutIter>::id;
2585  | 
2586  | _GLIBCXX_END_NAMESPACE_LDBL
2587  | 
2588  |   // Subclause convenience interfaces, inlines.
2589  |   // NB: These are inline because, when used in a loop, some compilers
2590  |   // can hoist the body out of the loop; then it's just as fast as the
2591  |   // C is*() function.
2592  | 
2593  |   /// Convenience interface to ctype.is(ctype_base::space, __c).
2594  |   template<typename _CharT>
2595  |     inline bool
2596  |     isspace(_CharT __c, const locale& __loc)
2597  |     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }
2598  | 
2599  |   /// Convenience interface to ctype.is(ctype_base::print, __c).
2600  |   template<typename _CharT>
2601  |     inline bool
2602  |     isprint(_CharT __c, const locale& __loc)
2603  |     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }
2604  | 
2605  |   /// Convenience interface to ctype.is(ctype_base::cntrl, __c).
2606  |   template<typename _CharT>
2607  |     inline bool
2608  |     iscntrl(_CharT __c, const locale& __loc)
2609  |     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }
2610  | 
2611  |   /// Convenience interface to ctype.is(ctype_base::upper, __c).
2612  |   template<typename _CharT>
2613  |     inline bool
2614  |     isupper(_CharT __c, const locale& __loc)
2615  |     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }
2616  | 
2617  |   /// Convenience interface to ctype.is(ctype_base::lower, __c).
2618  |   template<typename _CharT>
2619  |     inline bool
2620  |     islower(_CharT __c, const locale& __loc)
2621  |     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }
2622  | 
2623  |   /// Convenience interface to ctype.is(ctype_base::alpha, __c).
2624  |   template<typename _CharT>
2625  |     inline bool
2626  |     isalpha(_CharT __c, const locale& __loc)
2627  |     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }
2628  | 
2629  |   /// Convenience interface to ctype.is(ctype_base::digit, __c).
2630  |   template<typename _CharT>
2631  |     inline bool
2632  |     isdigit(_CharT __c, const locale& __loc)
2633  |     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }
2634  | 
2635  |   /// Convenience interface to ctype.is(ctype_base::punct, __c).
2636  |   template<typename _CharT>
2637  |     inline bool
2638  |     ispunct(_CharT __c, const locale& __loc)
2639  |     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }
2640  | 
2641  |   /// Convenience interface to ctype.is(ctype_base::xdigit, __c).
2642  |   template<typename _CharT>
2643  |     inline bool
2644  |     isxdigit(_CharT __c, const locale& __loc)
2645  |     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }
2646  | 
2647  |   /// Convenience interface to ctype.is(ctype_base::alnum, __c).
2648  |   template<typename _CharT>
2649  |     inline bool
2650  |     isalnum(_CharT __c, const locale& __loc)
2651  |     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }
2652  | 
2653  |   /// Convenience interface to ctype.is(ctype_base::graph, __c).
2654  |   template<typename _CharT>
2655  |     inline bool
2656  |     isgraph(_CharT __c, const locale& __loc)
2657  |     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }
2658  | 
2659  | #if __cplusplus >= 201103L
2660  |   /// Convenience interface to ctype.is(ctype_base::blank, __c).
2661  |   template<typename _CharT>
2662  |     inline bool
2663  |     isblank(_CharT __c, const locale& __loc)
2664  |     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }
2665  | #endif
2666  | 
2667  |   /// Convenience interface to ctype.toupper(__c).
2668  |   template<typename _CharT>
2669  |     inline _CharT
2670  |     toupper(_CharT __c, const locale& __loc)
2671  |     { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }
2672  | 
2673  |   /// Convenience interface to ctype.tolower(__c).
2674  |   template<typename _CharT>
2675  |     inline _CharT
2676  |     tolower(_CharT __c, const locale& __loc)
2677  |     { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }
2678  | 
2679  | _GLIBCXX_END_NAMESPACE_VERSION
2680  | } // namespace std
2681  | 
2682  | # include <bits/locale_facets.tcc>
2683  | 
2684  | #endif

< /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/iostream
 1  | // Standard iostream objects -*- C++ -*-
 2  | 
 3  | // Copyright (C) 1997-2021 Free Software Foundation, Inc.
 4  | //
 5  | // This file is part of the GNU ISO C++ Library.  This library is free
 6  | // software; you can redistribute it and/or modify it under the
 7  | // terms of the GNU General Public License as published by the
 8  | // Free Software Foundation; either version 3, or (at your option)
 9  | // any later version.
10  | 
11  | // This library is distributed in the hope that it will be useful,
12  | // but WITHOUT ANY WARRANTY; without even the implied warranty of
13  | // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
14  | // GNU General Public License for more details.
15  | 
16  | // Under Section 7 of GPL version 3, you are granted additional
17  | // permissions described in the GCC Runtime Library Exception, version
18  | // 3.1, as published by the Free Software Foundation.
19  | 
20  | // You should have received a copy of the GNU General Public License and
21  | // a copy of the GCC Runtime Library Exception along with this program;
22  | // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
23  | // <http://www.gnu.org/licenses/>.
24  | 
25  | /** @file include/iostream
26  |  *  This is a Standard C++ Library header.
27  |  */
28  | 
29  | //
30  | // ISO C++ 14882: 27.3  Standard iostream objects
31  | //
32  | 
33  | #ifndef _GLIBCXX_IOSTREAM
34  | #define _GLIBCXX_IOSTREAM 1
35  | 
36  | #pragma GCC system_header
37  | 
38  | #include <bits/c++config.h>
39  | #include <ostream>
40  | #include <istream>
41  | 
42  | namespace std _GLIBCXX_VISIBILITY(default)
43  | {
44  | _GLIBCXX_BEGIN_NAMESPACE_VERSION
45  | 
46  |   /**
47  |    *  @name Standard Stream Objects
48  |    *
49  |    *  The &lt;iostream&gt; header declares the eight <em>standard stream
50  |    *  objects</em>.  For other declarations, see
51  |    *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/io.html
52  |    *  and the @link iosfwd I/O forward declarations @endlink
53  |    *
54  |    *  They are required by default to cooperate with the global C
55  |    *  library's @c FILE streams, and to be available during program
56  |    *  startup and termination. For more information, see the section of the
57  |    *  manual linked to above.
58  |   */
59  |   ///@{
60  |   extern istream cin;		/// Linked to standard input
61  |   extern ostream cout;		/// Linked to standard output
62  |   extern ostream cerr;		/// Linked to standard error (unbuffered)
63  |   extern ostream clog;		/// Linked to standard error (buffered)
64  | 
65  | #ifdef _GLIBCXX_USE_WCHAR_T
66  |   extern wistream wcin;		/// Linked to standard input
67  |   extern wostream wcout;	/// Linked to standard output
68  |   extern wostream wcerr;	/// Linked to standard error (unbuffered)
69  |   extern wostream wclog;	/// Linked to standard error (buffered)
70  | #endif
71  |   ///@}
72  | 
73  |   // For construction of filebuffers for cout, cin, cerr, clog et. al.
74  |   static ios_base::Init __ioinit;
75  | 
76  | _GLIBCXX_END_NAMESPACE_VERSION
77  | } // namespace
78  | 
79  | #endif /* _GLIBCXX_IOSTREAM */

< /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/istream
  1  | // Input streams -*- C++ -*-
  2  | 
  3  | // Copyright (C) 1997-2021 Free Software Foundation, Inc.
  4  | //
  5  | // This file is part of the GNU ISO C++ Library.  This library is free
  6  | // software; you can redistribute it and/or modify it under the
  7  | // terms of the GNU General Public License as published by the
  8  | // Free Software Foundation; either version 3, or (at your option)
  9  | // any later version.
 10  | 
 11  | // This library is distributed in the hope that it will be useful,
 12  | // but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  | // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 14  | // GNU General Public License for more details.
 15  | 
 16  | // Under Section 7 of GPL version 3, you are granted additional
 17  | // permissions described in the GCC Runtime Library Exception, version
 18  | // 3.1, as published by the Free Software Foundation.
 19  | 
 20  | // You should have received a copy of the GNU General Public License and
 21  | // a copy of the GCC Runtime Library Exception along with this program;
 22  | // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 23  | // <http://www.gnu.org/licenses/>.
 24  | 
 25  | //
 26  | // ISO C++ 14882: 27.6.1  Input streams
 27  | //
 28  | 
 29  | /** @file include/istream
 30  |  *  This is a Standard C++ Library header.
 31  |  */
 32  | 
 33  | #ifndef _GLIBCXX_ISTREAM
 34  | #define _GLIBCXX_ISTREAM 1
 35  | 
 36  | #pragma GCC system_header
 37  | 
 38  | #include <ios>
 39  | #include <ostream>
 40  | 
 41  | namespace std _GLIBCXX_VISIBILITY(default)
 42  | {
 43  | _GLIBCXX_BEGIN_NAMESPACE_VERSION
 44  | 
 45  |   /**
 46  |    *  @brief  Template class basic_istream.
 47  |    *  @ingroup io
 48  |    *
 49  |    *  @tparam _CharT  Type of character stream.
 50  |    *  @tparam _Traits  Traits for character type, defaults to
 51  |    *                   char_traits<_CharT>.
 52  |    *
 53  |    *  This is the base class for all input streams.  It provides text
 54  |    *  formatting of all builtin types, and communicates with any class
 55  |    *  derived from basic_streambuf to do the actual input.
 56  |   */
 57  |   template<typename _CharT, typename _Traits>
 58  |     class basic_istream : virtual public basic_ios<_CharT, _Traits>
 59  |     {
 60  |     public:
 61  |       // Types (inherited from basic_ios (27.4.4)):
 62  |       typedef _CharT			 		char_type;
 63  |       typedef typename _Traits::int_type 		int_type;
 64  |       typedef typename _Traits::pos_type 		pos_type;
 65  |       typedef typename _Traits::off_type 		off_type;
 66  |       typedef _Traits			 		traits_type;
 67  | 
 68  |       // Non-standard Types:
 69  |       typedef basic_streambuf<_CharT, _Traits> 		__streambuf_type;
 70  |       typedef basic_ios<_CharT, _Traits>		__ios_type;
 71  |       typedef basic_istream<_CharT, _Traits>		__istream_type;
 72  |       typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
 73  |  							__num_get_type;
 74  |       typedef ctype<_CharT>	      			__ctype_type;
 75  | 
 76  |     protected:
 77  |       // Data Members:
 78  |       /**
 79  |        *  The number of characters extracted in the previous unformatted
 80  |        *  function; see gcount().
 81  |       */
 82  |       streamsize 		_M_gcount;
 83  | 
 84  |     public:
 85  |       /**
 86  |        *  @brief  Base constructor.
 87  |        *
 88  |        *  This ctor is almost never called by the user directly, rather from
 89  |        *  derived classes' initialization lists, which pass a pointer to
 90  |        *  their own stream buffer.
 91  |       */
 92  |       explicit
 93  |       basic_istream(__streambuf_type* __sb)
 94  |       : _M_gcount(streamsize(0))
 95  |       { this->init(__sb); }
 96  | 
 97  |       /**
 98  |        *  @brief  Base destructor.
 99  |        *
100  |        *  This does very little apart from providing a virtual base dtor.
101  |       */
102  |       virtual
103  |       ~basic_istream()
104  |       { _M_gcount = streamsize(0); }
105  | 
106  |       /// Safe prefix/suffix operations.
107  |       class sentry;
108  |       friend class sentry;
109  | 
110  |       ///@{
111  |       /**
112  |        *  @brief  Interface for manipulators.
113  |        *
114  |        *  Manipulators such as @c std::ws and @c std::dec use these
115  |        *  functions in constructs like
116  |        *  <code>std::cin >> std::ws</code>.
117  |        *  For more information, see the iomanip header.
118  |       */
119  |       __istream_type&
120  |       operator>>(__istream_type& (*__pf)(__istream_type&))
121  |       { return __pf(*this); }
122  | 
123  |       __istream_type&
124  |       operator>>(__ios_type& (*__pf)(__ios_type&))
125  |       {
126  | 	__pf(*this);
127  | 	return *this;
128  |       }
129  | 
130  |       __istream_type&
131  |       operator>>(ios_base& (*__pf)(ios_base&))
132  |       {
133  | 	__pf(*this);
134  | 	return *this;
135  |       }
136  |       ///@}
137  | 
138  |       ///@{
139  |       /**
140  |        *  @name Extractors
141  |        *
142  |        *  All the @c operator>> functions (aka <em>formatted input
143  |        *  functions</em>) have some common behavior.  Each starts by
144  |        *  constructing a temporary object of type std::basic_istream::sentry
145  |        *  with the second argument (noskipws) set to false.  This has several
146  |        *  effects, concluding with the setting of a status flag; see the
147  |        *  sentry documentation for more.
148  |        *
149  |        *  If the sentry status is good, the function tries to extract
150  |        *  whatever data is appropriate for the type of the argument.
151  |        *
152  |        *  If an exception is thrown during extraction, ios_base::badbit
153  |        *  will be turned on in the stream's error state (without causing an
154  |        *  ios_base::failure to be thrown) and the original exception will
155  |        *  be rethrown if badbit is set in the exceptions mask.
156  |       */
157  | 
158  |       ///@{
159  |       /**
160  |        *  @brief  Integer arithmetic extractors
161  |        *  @param  __n A variable of builtin integral type.
162  |        *  @return  @c *this if successful
163  |        *
164  |        *  These functions use the stream's current locale (specifically, the
165  |        *  @c num_get facet) to parse the input data.
166  |       */
167  |       __istream_type&
168  |       operator>>(bool& __n)
169  |       { return _M_extract(__n); }
170  | 
171  |       __istream_type&
172  |       operator>>(short& __n);
173  | 
174  |       __istream_type&
175  |       operator>>(unsigned short& __n)
176  |       { return _M_extract(__n); }
177  | 
178  |       __istream_type&
179  |       operator>>(int& __n);
180  | 
181  |       __istream_type&
182  |       operator>>(unsigned int& __n)
183  |       { return _M_extract(__n); }
184  | 
185  |       __istream_type&
186  |       operator>>(long& __n)
187  |       { return _M_extract(__n); }
188  | 
189  |       __istream_type&
190  |       operator>>(unsigned long& __n)
191  |       { return _M_extract(__n); }
192  | 
193  | #ifdef _GLIBCXX_USE_LONG_LONG
194  |       __istream_type&
195  |       operator>>(long long& __n)
196  |       { return _M_extract(__n); }
197  | 
198  |       __istream_type&
199  |       operator>>(unsigned long long& __n)
200  |       { return _M_extract(__n); }
201  | #endif
202  |       ///@}
203  | 
204  |       ///@{
205  |       /**
206  |        *  @brief  Floating point arithmetic extractors
207  |        *  @param  __f A variable of builtin floating point type.
208  |        *  @return  @c *this if successful
209  |        *
210  |        *  These functions use the stream's current locale (specifically, the
211  |        *  @c num_get facet) to parse the input data.
212  |       */
213  |       __istream_type&
214  |       operator>>(float& __f)
215  |       { return _M_extract(__f); }
216  | 
217  |       __istream_type&
218  |       operator>>(double& __f)
219  |       { return _M_extract(__f); }
220  | 
221  |       __istream_type&
222  |       operator>>(long double& __f)
223  |       { return _M_extract(__f); }
224  |       ///@}
225  | 
226  |       /**
227  |        *  @brief  Basic arithmetic extractors
228  |        *  @param  __p A variable of pointer type.
229  |        *  @return  @c *this if successful
230  |        *
231  |        *  These functions use the stream's current locale (specifically, the
232  |        *  @c num_get facet) to parse the input data.
233  |       */
234  |       __istream_type&
235  |       operator>>(void*& __p)
236  |       { return _M_extract(__p); }
237  | 
238  |       /**
239  |        *  @brief  Extracting into another streambuf.
240  |        *  @param  __sb  A pointer to a streambuf
241  |        *
242  |        *  This function behaves like one of the basic arithmetic extractors,
243  |        *  in that it also constructs a sentry object and has the same error
244  |        *  handling behavior.
245  |        *
246  |        *  If @p __sb is NULL, the stream will set failbit in its error state.
247  |        *
248  |        *  Characters are extracted from this stream and inserted into the
249  |        *  @p __sb streambuf until one of the following occurs:
250  |        *
251  |        *  - the input stream reaches end-of-file,
252  |        *  - insertion into the output buffer fails (in this case, the
253  |        *    character that would have been inserted is not extracted), or
254  |        *  - an exception occurs (and in this case is caught)
255  |        *
256  |        *  If the function inserts no characters, failbit is set.
257  |       */
258  |       __istream_type&
259  |       operator>>(__streambuf_type* __sb);
260  |       ///@}
261  | 
262  |       // [27.6.1.3] unformatted input
263  |       /**
264  |        *  @brief  Character counting
265  |        *  @return  The number of characters extracted by the previous
266  |        *           unformatted input function dispatched for this stream.
267  |       */
268  |       streamsize
269  |       gcount() const
270  |       { return _M_gcount; }
271  | 
272  |       ///@{
273  |       /**
274  |        *  @name Unformatted Input Functions
275  |        *
276  |        *  All the unformatted input functions have some common behavior.
277  |        *  Each starts by constructing a temporary object of type
278  |        *  std::basic_istream::sentry with the second argument (noskipws)
279  |        *  set to true.  This has several effects, concluding with the
280  |        *  setting of a status flag; see the sentry documentation for more.
281  |        *
282  |        *  If the sentry status is good, the function tries to extract
283  |        *  whatever data is appropriate for the type of the argument.
284  |        *
285  |        *  The number of characters extracted is stored for later retrieval
286  |        *  by gcount().
287  |        *
288  |        *  If an exception is thrown during extraction, ios_base::badbit
289  |        *  will be turned on in the stream's error state (without causing an
290  |        *  ios_base::failure to be thrown) and the original exception will
291  |        *  be rethrown if badbit is set in the exceptions mask.
292  |       */
293  | 
294  |       /**
295  |        *  @brief  Simple extraction.
296  |        *  @return  A character, or eof().
297  |        *
298  |        *  Tries to extract a character.  If none are available, sets failbit
299  |        *  and returns traits::eof().
300  |       */
301  |       int_type
302  |       get();
303  | 
304  |       /**
305  |        *  @brief  Simple extraction.
306  |        *  @param  __c  The character in which to store data.
307  |        *  @return  *this
308  |        *
309  |        *  Tries to extract a character and store it in @a __c.  If none are
310  |        *  available, sets failbit and returns traits::eof().
311  |        *
312  |        *  @note  This function is not overloaded on signed char and
313  |        *         unsigned char.
314  |       */
315  |       __istream_type&
316  |       get(char_type& __c);
317  | 
318  |       /**
319  |        *  @brief  Simple multiple-character extraction.
320  |        *  @param  __s  Pointer to an array.
321  |        *  @param  __n  Maximum number of characters to store in @a __s.
322  |        *  @param  __delim  A "stop" character.
323  |        *  @return  *this
324  |        *
325  |        *  Characters are extracted and stored into @a __s until one of the
326  |        *  following happens:
327  |        *
328  |        *  - @c __n-1 characters are stored
329  |        *  - the input sequence reaches EOF
330  |        *  - the next character equals @a __delim, in which case the character
331  |        *    is not extracted
332  |        *
333  |        * If no characters are stored, failbit is set in the stream's error
334  |        * state.
335  |        *
336  |        * In any case, a null character is stored into the next location in
337  |        * the array.
338  |        *
339  |        *  @note  This function is not overloaded on signed char and
340  |        *         unsigned char.
341  |       */
342  |       __istream_type&
343  |       get(char_type* __s, streamsize __n, char_type __delim);
344  | 
345  |       /**
346  |        *  @brief  Simple multiple-character extraction.
347  |        *  @param  __s  Pointer to an array.
348  |        *  @param  __n  Maximum number of characters to store in @a s.
349  |        *  @return  *this
350  |        *
351  |        *  Returns @c get(__s,__n,widen(&apos;\\n&apos;)).
352  |       */
353  |       __istream_type&
354  |       get(char_type* __s, streamsize __n)
355  |       { return this->get(__s, __n, this->widen('\n')); }
356  | 
357  |       /**
358  |        *  @brief  Extraction into another streambuf.
359  |        *  @param  __sb  A streambuf in which to store data.
360  |        *  @param  __delim  A "stop" character.
361  |        *  @return  *this
362  |        *
363  |        *  Characters are extracted and inserted into @a __sb until one of the
364  |        *  following happens:
365  |        *
366  |        *  - the input sequence reaches EOF
367  |        *  - insertion into the output buffer fails (in this case, the
368  |        *    character that would have been inserted is not extracted)
369  |        *  - the next character equals @a __delim (in this case, the character
370  |        *    is not extracted)
371  |        *  - an exception occurs (and in this case is caught)
372  |        *
373  |        * If no characters are stored, failbit is set in the stream's error
374  |        * state.
375  |       */
376  |       __istream_type&
377  |       get(__streambuf_type& __sb, char_type __delim);
378  | 
379  |       /**
380  |        *  @brief  Extraction into another streambuf.
381  |        *  @param  __sb  A streambuf in which to store data.
382  |        *  @return  *this
383  |        *
384  |        *  Returns @c get(__sb,widen(&apos;\\n&apos;)).
385  |       */
386  |       __istream_type&
387  |       get(__streambuf_type& __sb)
388  |       { return this->get(__sb, this->widen('\n')); }
389  | 
390  |       /**
391  |        *  @brief  String extraction.
392  |        *  @param  __s  A character array in which to store the data.
393  |        *  @param  __n  Maximum number of characters to extract.
394  |        *  @param  __delim  A "stop" character.
395  |        *  @return  *this
396  |        *
397  |        *  Extracts and stores characters into @a __s until one of the
398  |        *  following happens.  Note that these criteria are required to be
399  |        *  tested in the order listed here, to allow an input line to exactly
400  |        *  fill the @a __s array without setting failbit.
401  |        *
402  |        *  -# the input sequence reaches end-of-file, in which case eofbit
403  |        *     is set in the stream error state
404  |        *  -# the next character equals @c __delim, in which case the character
405  |        *     is extracted (and therefore counted in @c gcount()) but not stored
406  |        *  -# @c __n-1 characters are stored, in which case failbit is set
407  |        *     in the stream error state
408  |        *
409  |        *  If no characters are extracted, failbit is set.  (An empty line of
410  |        *  input should therefore not cause failbit to be set.)
411  |        *
412  |        *  In any case, a null character is stored in the next location in
413  |        *  the array.
414  |       */
415  |       __istream_type&
416  |       getline(char_type* __s, streamsize __n, char_type __delim);
417  | 
418  |       /**
419  |        *  @brief  String extraction.
420  |        *  @param  __s  A character array in which to store the data.
421  |        *  @param  __n  Maximum number of characters to extract.
422  |        *  @return  *this
423  |        *
424  |        *  Returns @c getline(__s,__n,widen(&apos;\\n&apos;)).
425  |       */
426  |       __istream_type&
427  |       getline(char_type* __s, streamsize __n)
428  |       { return this->getline(__s, __n, this->widen('\n')); }
429  | 
430  |       /**
431  |        *  @brief  Discarding characters
432  |        *  @param  __n  Number of characters to discard.
433  |        *  @param  __delim  A "stop" character.
434  |        *  @return  *this
435  |        *
436  |        *  Extracts characters and throws them away until one of the
437  |        *  following happens:
438  |        *  - if @a __n @c != @c std::numeric_limits<int>::max(), @a __n
439  |        *    characters are extracted
440  |        *  - the input sequence reaches end-of-file
441  |        *  - the next character equals @a __delim (in this case, the character
442  |        *    is extracted); note that this condition will never occur if
443  |        *    @a __delim equals @c traits::eof().
444  |        *
445  |        *  NB: Provide three overloads, instead of the single function
446  |        *  (with defaults) mandated by the Standard: this leads to a
447  |        *  better performing implementation, while still conforming to
448  |        *  the Standard.
449  |       */
450  |       __istream_type&
451  |       ignore(streamsize __n, int_type __delim);
452  | 
453  |       __istream_type&
454  |       ignore(streamsize __n);
455  | 
456  |       __istream_type&
457  |       ignore();
458  | 
459  |       /**
460  |        *  @brief  Looking ahead in the stream
461  |        *  @return  The next character, or eof().
462  |        *
463  |        *  If, after constructing the sentry object, @c good() is false,
464  |        *  returns @c traits::eof().  Otherwise reads but does not extract
465  |        *  the next input character.
466  |       */
467  |       int_type
468  |       peek();
469  | 
470  |       /**
471  |        *  @brief  Extraction without delimiters.
472  |        *  @param  __s  A character array.
473  |        *  @param  __n  Maximum number of characters to store.
474  |        *  @return  *this
475  |        *
476  |        *  If the stream state is @c good(), extracts characters and stores
477  |        *  them into @a __s until one of the following happens:
478  |        *  - @a __n characters are stored
479  |        *  - the input sequence reaches end-of-file, in which case the error
480  |        *    state is set to @c failbit|eofbit.
481  |        *
482  |        *  @note  This function is not overloaded on signed char and
483  |        *         unsigned char.
484  |       */
485  |       __istream_type&
486  |       read(char_type* __s, streamsize __n);
487  | 
488  |       /**
489  |        *  @brief  Extraction until the buffer is exhausted, but no more.
490  |        *  @param  __s  A character array.
491  |        *  @param  __n  Maximum number of characters to store.
492  |        *  @return  The number of characters extracted.
493  |        *
494  |        *  Extracts characters and stores them into @a __s depending on the
495  |        *  number of characters remaining in the streambuf's buffer,
496  |        *  @c rdbuf()->in_avail(), called @c A here:
497  |        *  - if @c A @c == @c -1, sets eofbit and extracts no characters
498  |        *  - if @c A @c == @c 0, extracts no characters
499  |        *  - if @c A @c > @c 0, extracts @c min(A,n)
500  |        *
501  |        *  The goal is to empty the current buffer, and to not request any
502  |        *  more from the external input sequence controlled by the streambuf.
503  |       */
504  |       streamsize
505  |       readsome(char_type* __s, streamsize __n);
506  | 
507  |       /**
508  |        *  @brief  Unextracting a single character.
509  |        *  @param  __c  The character to push back into the input stream.
510  |        *  @return  *this
511  |        *
512  |        *  If @c rdbuf() is not null, calls @c rdbuf()->sputbackc(c).
513  |        *
514  |        *  If @c rdbuf() is null or if @c sputbackc() fails, sets badbit in
515  |        *  the error state.
516  |        *
517  |        *  @note  This function first clears eofbit.  Since no characters
518  |        *         are extracted, the next call to @c gcount() will return 0,
519  |        *         as required by DR 60.
520  |       */
521  |       __istream_type&
522  |       putback(char_type __c);
523  | 
524  |       /**
525  |        *  @brief  Unextracting the previous character.
526  |        *  @return  *this
527  |        *
528  |        *  If @c rdbuf() is not null, calls @c rdbuf()->sungetc(c).
529  |        *
530  |        *  If @c rdbuf() is null or if @c sungetc() fails, sets badbit in
531  |        *  the error state.
532  |        *
533  |        *  @note  This function first clears eofbit.  Since no characters
534  |        *         are extracted, the next call to @c gcount() will return 0,
535  |        *         as required by DR 60.
536  |       */
537  |       __istream_type&
538  |       unget();
539  | 
540  |       /**
541  |        *  @brief  Synchronizing the stream buffer.
542  |        *  @return  0 on success, -1 on failure
543  |        *
544  |        *  If @c rdbuf() is a null pointer, returns -1.
545  |        *
546  |        *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,
547  |        *  sets badbit and returns -1.
548  |        *
549  |        *  Otherwise, returns 0.
550  |        *
551  |        *  @note  This function does not count the number of characters
552  |        *         extracted, if any, and therefore does not affect the next
553  |        *         call to @c gcount().
554  |       */
555  |       int
556  |       sync();
557  | 
558  |       /**
559  |        *  @brief  Getting the current read position.
560  |        *  @return  A file position object.
561  |        *
562  |        *  If @c fail() is not false, returns @c pos_type(-1) to indicate
563  |        *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,in).
564  |        *
565  |        *  @note  This function does not count the number of characters
566  |        *         extracted, if any, and therefore does not affect the next
567  |        *         call to @c gcount().  At variance with putback, unget and
568  |        *         seekg, eofbit is not cleared first.
569  |       */
570  |       pos_type
571  |       tellg();
572  | 
573  |       /**
574  |        *  @brief  Changing the current read position.
575  |        *  @param  __pos  A file position object.
576  |        *  @return  *this
577  |        *
578  |        *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(__pos).  If
579  |        *  that function fails, sets failbit.
580  |        *
581  |        *  @note  This function first clears eofbit.  It does not count the
582  |        *         number of characters extracted, if any, and therefore does
583  |        *         not affect the next call to @c gcount().
584  |       */
585  |       __istream_type&
586  |       seekg(pos_type);
587  | 
588  |       /**
589  |        *  @brief  Changing the current read position.
590  |        *  @param  __off  A file offset object.
591  |        *  @param  __dir  The direction in which to seek.
592  |        *  @return  *this
593  |        *
594  |        *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(__off,__dir).
595  |        *  If that function fails, sets failbit.
596  |        *
597  |        *  @note  This function first clears eofbit.  It does not count the
598  |        *         number of characters extracted, if any, and therefore does
599  |        *         not affect the next call to @c gcount().
600  |       */
601  |       __istream_type&
602  |       seekg(off_type, ios_base::seekdir);
603  |       ///@}
604  | 
605  |     protected:
606  |       basic_istream()
607  |       : _M_gcount(streamsize(0))
608  |       { this->init(0); }
609  | 
610  | #if __cplusplus >= 201103L
611  |       basic_istream(const basic_istream&) = delete;
612  | 
613  |       basic_istream(basic_istream&& __rhs)
614  |       : __ios_type(), _M_gcount(__rhs._M_gcount)
615  |       {
616  | 	__ios_type::move(__rhs);
617  | 	__rhs._M_gcount = 0;
618  |       }
619  | 
620  |       // 27.7.3.3 Assign/swap
621  | 
622  |       basic_istream& operator=(const basic_istream&) = delete;
623  | 
624  |       basic_istream&
625  |       operator=(basic_istream&& __rhs)
626  |       {
627  | 	swap(__rhs);
628  | 	return *this;
629  |       }
630  | 
631  |       void
632  |       swap(basic_istream& __rhs)
633  |       {
634  | 	__ios_type::swap(__rhs);
635  | 	std::swap(_M_gcount, __rhs._M_gcount);
636  |       }
637  | #endif
638  | 
639  |       template<typename _ValueT>
640  | 	__istream_type&
641  | 	_M_extract(_ValueT& __v);
642  |     };
643  | 
644  |   /// Explicit specialization declarations, defined in src/istream.cc.
645  |   template<>
646  |     basic_istream<char>&
647  |     basic_istream<char>::
648  |     getline(char_type* __s, streamsize __n, char_type __delim);
649  | 
650  |   template<>
651  |     basic_istream<char>&
652  |     basic_istream<char>::
653  |     ignore(streamsize __n);
654  | 
655  |   template<>
656  |     basic_istream<char>&
657  |     basic_istream<char>::
658  |     ignore(streamsize __n, int_type __delim);
659  | 
660  | #ifdef _GLIBCXX_USE_WCHAR_T
661  |   template<>
662  |     basic_istream<wchar_t>&
663  |     basic_istream<wchar_t>::
664  |     getline(char_type* __s, streamsize __n, char_type __delim);
665  | 
666  |   template<>
667  |     basic_istream<wchar_t>&
668  |     basic_istream<wchar_t>::
669  |     ignore(streamsize __n);
670  | 
671  |   template<>
672  |     basic_istream<wchar_t>&
673  |     basic_istream<wchar_t>::
674  |     ignore(streamsize __n, int_type __delim);
675  | #endif
676  | 
677  |   /**
678  |    *  @brief  Performs setup work for input streams.
679  |    *
680  |    *  Objects of this class are created before all of the standard
681  |    *  extractors are run.  It is responsible for <em>exception-safe
682  |    *  prefix and suffix operations,</em> although only prefix actions
683  |    *  are currently required by the standard.
684  |   */
685  |   template<typename _CharT, typename _Traits>
686  |     class basic_istream<_CharT, _Traits>::sentry
687  |     {
688  |       // Data Members.
689  |       bool _M_ok;
690  | 
691  |     public:
692  |       /// Easy access to dependent types.
693  |       typedef _Traits 					traits_type;
694  |       typedef basic_streambuf<_CharT, _Traits> 		__streambuf_type;
695  |       typedef basic_istream<_CharT, _Traits> 		__istream_type;
696  |       typedef typename __istream_type::__ctype_type 	__ctype_type;
697  |       typedef typename _Traits::int_type		__int_type;
698  | 
699  |       /**
700  |        *  @brief  The constructor performs all the work.
701  |        *  @param  __is  The input stream to guard.
702  |        *  @param  __noskipws  Whether to consume whitespace or not.
703  |        *
704  |        *  If the stream state is good (@a __is.good() is true), then the
705  |        *  following actions are performed, otherwise the sentry state
706  |        *  is false (<em>not okay</em>) and failbit is set in the
707  |        *  stream state.
708  |        *
709  |        *  The sentry's preparatory actions are:
710  |        *
711  |        *  -# if the stream is tied to an output stream, @c is.tie()->flush()
712  |        *     is called to synchronize the output sequence
713  |        *  -# if @a __noskipws is false, and @c ios_base::skipws is set in
714  |        *     @c is.flags(), the sentry extracts and discards whitespace
715  |        *     characters from the stream.  The currently imbued locale is
716  |        *     used to determine whether each character is whitespace.
717  |        *
718  |        *  If the stream state is still good, then the sentry state becomes
719  |        *  true (@a okay).
720  |       */
721  |       explicit
722  |       sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
723  | 
724  |       /**
725  |        *  @brief  Quick status checking.
726  |        *  @return  The sentry state.
727  |        *
728  |        *  For ease of use, sentries may be converted to booleans.  The
729  |        *  return value is that of the sentry state (true == okay).
730  |       */
731  | #if __cplusplus >= 201103L
732  |       explicit
733  | #endif
734  |       operator bool() const
735  |       { return _M_ok; }
736  |     };
737  | 
738  |   ///@{
739  |   /**
740  |    *  @brief  Character extractors
741  |    *  @param  __in  An input stream.
742  |    *  @param  __c  A character reference.
743  |    *  @return  in
744  |    *
745  |    *  Behaves like one of the formatted arithmetic extractors described in
746  |    *  std::basic_istream.  After constructing a sentry object with good
747  |    *  status, this function extracts a character (if one is available) and
748  |    *  stores it in @a __c.  Otherwise, sets failbit in the input stream.
749  |   */
750  |   template<typename _CharT, typename _Traits>
751  |     basic_istream<_CharT, _Traits>&
752  |     operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);
753  | 
754  |   template<class _Traits>
755  |     inline basic_istream<char, _Traits>&
756  |     operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
757  |     { return (__in >> reinterpret_cast<char&>(__c)); }
758  | 
759  |   template<class _Traits>
760  |     inline basic_istream<char, _Traits>&
761  |     operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
762  |     { return (__in >> reinterpret_cast<char&>(__c)); }
763  |   ///@}
764  | 
765  | 
766  |   template<typename _CharT, typename _Traits>
767  |     void
768  |     __istream_extract(basic_istream<_CharT, _Traits>&, _CharT*, streamsize);
769  | 
770  |   void __istream_extract(istream&, char*, streamsize);
771  | 
772  |   ///@{
773  |   /**
774  |    *  @brief  Character string extractors
775  |    *  @param  __in  An input stream.
776  |    *  @param  __s  A character array (or a pointer to an array before C++20).
777  |    *  @return  __in
778  |    *
779  |    *  Behaves like one of the formatted arithmetic extractors described in
780  |    *  `std::basic_istream`.  After constructing a sentry object with good
781  |    *  status, this function extracts up to `n` characters and stores them
782  |    *  into the array `__s`.  `n` is defined as:
783  |    *
784  |    *  - if `width()` is greater than zero, `n` is `min(width(), n)`
785  |    *  - otherwise `n` is the number of elements of the array
786  |    *  - (before C++20 the pointer is assumed to point to an array of
787  |    *  - the largest possible size for an array of `char_type`).
788  |    *
789  |    *  Characters are extracted and stored until one of the following happens:
790  |    *  - `n - 1` characters are stored
791  |    *  - EOF is reached
792  |    *  - the next character is whitespace according to the current locale
793  |    *
794  |    *  `width(0)` is then called for the input stream.
795  |    *
796  |    *  If no characters are extracted, sets failbit.
797  |   */
798  | 
799  | #if __cplusplus <= 201703L
800  |   template<typename _CharT, typename _Traits>
801  |     __attribute__((__nonnull__(2), __access__(__write_only__, 2)))
802  |     inline basic_istream<_CharT, _Traits>&
803  |     operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
804  |     {
805  |       size_t __n = __builtin_object_size(__s, 0);
806  |       if (__builtin_expect(__n < sizeof(_CharT), false))
807  | 	{
808  | 	  // There is not even space for the required null terminator.
809  | 	  __glibcxx_assert(__n >= sizeof(_CharT));
810  | 	  __in.width(0);
811  | 	  __in.setstate(ios_base::failbit);
812  | 	}
813  |       else
814  | 	{
815  | 	  if (__n == (size_t)-1)
816  | 	    __n = __gnu_cxx::__numeric_traits<streamsize>::__max;
817  | 	  std::__istream_extract(__in, __s, __n / sizeof(_CharT));
818  | 	}
819  |       return __in;
820  |     }
821  | 
822  |   template<class _Traits>
823  |     __attribute__((__nonnull__(2), __access__(__write_only__, 2)))
824  |     inline basic_istream<char, _Traits>&
825  |     operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
826  |     { return __in >> reinterpret_cast<char*>(__s); }
827  | 
828  |   template<class _Traits>
829  |     __attribute__((__nonnull__(2), __access__(__write_only__, 2)))
830  |     inline basic_istream<char, _Traits>&
831  |     operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
832  |     { return __in >> reinterpret_cast<char*>(__s); }
833  | #else
834  |   // _GLIBCXX_RESOLVE_LIB_DEFECTS
835  |   // 2499. operator>>(istream&, char*) makes it hard to avoid buffer overflows
836  |   template<typename _CharT, typename _Traits, size_t _Num>
837  |     inline basic_istream<_CharT, _Traits>&
838  |     operator>>(basic_istream<_CharT, _Traits>& __in, _CharT (&__s)[_Num])
839  |     {
840  |       static_assert(_Num <= __gnu_cxx::__numeric_traits<streamsize>::__max);
841  |       std::__istream_extract(__in, __s, _Num);
842  |       return __in;
843  |     }
844  | 
845  |   template<class _Traits, size_t _Num>
846  |     inline basic_istream<char, _Traits>&
847  |     operator>>(basic_istream<char, _Traits>& __in, unsigned char (&__s)[_Num])
848  |     { return __in >> reinterpret_cast<char(&)[_Num]>(__s); }
849  | 
850  |   template<class _Traits, size_t _Num>
851  |     inline basic_istream<char, _Traits>&
852  |     operator>>(basic_istream<char, _Traits>& __in, signed char (&__s)[_Num])
853  |     { return __in >> reinterpret_cast<char(&)[_Num]>(__s); }
854  | #endif
855  |   ///@}
856  | 
857  |   /**
858  |    *  @brief  Template class basic_iostream
859  |    *  @ingroup io
860  |    *
861  |    *  @tparam _CharT  Type of character stream.
862  |    *  @tparam _Traits  Traits for character type, defaults to
863  |    *                   char_traits<_CharT>.
864  |    *
865  |    *  This class multiply inherits from the input and output stream classes
866  |    *  simply to provide a single interface.
867  |   */
868  |   template<typename _CharT, typename _Traits>
869  |     class basic_iostream
870  |     : public basic_istream<_CharT, _Traits>,
871  |       public basic_ostream<_CharT, _Traits>
872  |     {
873  |     public:
874  |       // _GLIBCXX_RESOLVE_LIB_DEFECTS
875  |       // 271. basic_iostream missing typedefs
876  |       // Types (inherited):
877  |       typedef _CharT			 		char_type;
878  |       typedef typename _Traits::int_type 		int_type;
879  |       typedef typename _Traits::pos_type 		pos_type;
880  |       typedef typename _Traits::off_type 		off_type;
881  |       typedef _Traits			 		traits_type;
882  | 
883  |       // Non-standard Types:
884  |       typedef basic_istream<_CharT, _Traits>		__istream_type;
885  |       typedef basic_ostream<_CharT, _Traits>		__ostream_type;
886  | 
887  |       /**
888  |        *  @brief  Constructor does nothing.
889  |        *
890  |        *  Both of the parent classes are initialized with the same
891  |        *  streambuf pointer passed to this constructor.
892  |       */
893  |       explicit
894  |       basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
895  |       : __istream_type(__sb), __ostream_type(__sb) { }
896  | 
897  |       /**
898  |        *  @brief  Destructor does nothing.
899  |       */
900  |       virtual
901  |       ~basic_iostream() { }
902  | 
903  |     protected:
904  |       basic_iostream()
905  |       : __istream_type(), __ostream_type() { }
906  | 
907  | #if __cplusplus >= 201103L
908  |       basic_iostream(const basic_iostream&) = delete;
909  | 
910  |       basic_iostream(basic_iostream&& __rhs)
911  |       : __istream_type(std::move(__rhs)), __ostream_type(*this)
912  |       { }
913  | 
914  |       // 27.7.3.3 Assign/swap
915  | 
916  |       basic_iostream& operator=(const basic_iostream&) = delete;
917  | 
918  |       basic_iostream&
919  |       operator=(basic_iostream&& __rhs)
920  |       {
921  | 	swap(__rhs);
922  | 	return *this;
923  |       }
924  | 
925  |       void
926  |       swap(basic_iostream& __rhs)
927  |       { __istream_type::swap(__rhs); }
928  | #endif
929  |     };
930  | 
931  |   /**
932  |    *  @brief  Quick and easy way to eat whitespace
933  |    *
934  |    *  This manipulator extracts whitespace characters, stopping when the
935  |    *  next character is non-whitespace, or when the input sequence is empty.
936  |    *  If the sequence is empty, @c eofbit is set in the stream, but not
937  |    *  @c failbit.
938  |    *
939  |    *  The current locale is used to distinguish whitespace characters.
940  |    *
941  |    *  Example:
942  |    *  @code
943  |    *     MyClass   mc;
944  |    *
945  |    *     std::cin >> std::ws >> mc;
946  |    *  @endcode
947  |    *  will skip leading whitespace before calling operator>> on cin and your
948  |    *  object.  Note that the same effect can be achieved by creating a
949  |    *  std::basic_istream::sentry inside your definition of operator>>.
950  |   */
951  |   template<typename _CharT, typename _Traits>
952  |     basic_istream<_CharT, _Traits>&
953  |     ws(basic_istream<_CharT, _Traits>& __is);
954  | 
955  | #if __cplusplus >= 201103L
956  |   // C++11 27.7.2.6 Rvalue stream extraction [istream.rvalue]
957  |   // _GLIBCXX_RESOLVE_LIB_DEFECTS
958  |   // 2328. Rvalue stream extraction should use perfect forwarding
959  |   // 1203. More useful rvalue stream insertion
960  | 
961  | #if __cpp_lib_concepts
962  |   template<typename _Is, typename _Tp>
963  |     requires __derived_from_ios_base<_Is>
964  |       && requires (_Is& __is, _Tp&& __t) { __is >> std::forward<_Tp>(__t); }
965  |     using __rvalue_stream_extraction_t = _Is&&;
966  | #else
967  |   template<typename _Is, typename _Tp,
968  | 	   typename = _Require_derived_from_ios_base<_Is>,
969  | 	   typename = decltype(std::declval<_Is&>() >> std::declval<_Tp>())>
970  |     using __rvalue_stream_extraction_t = _Is&&;
971  | #endif
972  | 
973  |   /**
974  |    *  @brief  Generic extractor for rvalue stream
975  |    *  @param  __is  An input stream.
976  |    *  @param  __x  A reference to the extraction target.
977  |    *  @return  __is
978  |    *
979  |    *  This is just a forwarding function to allow extraction from
980  |    *  rvalue streams since they won't bind to the extractor functions
981  |    *  that take an lvalue reference.
982  |   */
983  |   template<typename _Istream, typename _Tp>
984  |     inline __rvalue_stream_extraction_t<_Istream, _Tp>
985  |     operator>>(_Istream&& __is, _Tp&& __x)
986  |     {
987  |       __is >> std::forward<_Tp>(__x);
988  |       return std::move(__is);
989  |     }
990  | #endif // C++11
991  | 
992  | _GLIBCXX_END_NAMESPACE_VERSION
993  | } // namespace
994  | 
995  | #include <bits/istream.tcc>
996  | 
997  | #endif	/* _GLIBCXX_ISTREAM */

< /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/ostream
  1   | // Output streams -*- C++ -*-
  2   | 
  3   | // Copyright (C) 1997-2021 Free Software Foundation, Inc.
  4   | //
  5   | // This file is part of the GNU ISO C++ Library.  This library is free
  6   | // software; you can redistribute it and/or modify it under the
  7   | // terms of the GNU General Public License as published by the
  8   | // Free Software Foundation; either version 3, or (at your option)
  9   | // any later version.
 10   | 
 11   | // This library is distributed in the hope that it will be useful,
 12   | // but WITHOUT ANY WARRANTY; without even the implied warranty of
 13   | // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 14   | // GNU General Public License for more details.
 15   | 
 16   | // Under Section 7 of GPL version 3, you are granted additional
 17   | // permissions described in the GCC Runtime Library Exception, version
 18   | // 3.1, as published by the Free Software Foundation.
 19   | 
 20   | // You should have received a copy of the GNU General Public License and
 21   | // a copy of the GCC Runtime Library Exception along with this program;
 22   | // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 23   | // <http://www.gnu.org/licenses/>.
 24   | 
 25   | /** @file include/ostream
 26   |  *  This is a Standard C++ Library header.
 27   |  */
 28   | 
 29   | //
 30   | // ISO C++ 14882: 27.6.2  Output streams
 31   | //
 32   | 
 33   | #ifndef _GLIBCXX_OSTREAM
 34   | #define _GLIBCXX_OSTREAM 1
 35   | 
 36   | #pragma GCC system_header
 37   | 
 38   | #include <ios>
 39   | #include <bits/ostream_insert.h>
 40   | 
 41   | namespace std _GLIBCXX_VISIBILITY(default)
 42   | {
 43   | _GLIBCXX_BEGIN_NAMESPACE_VERSION
 44   | 
 45   |   /**
 46   |    *  @brief  Template class basic_ostream.
 47   |    *  @ingroup io
 48   |    *
 49   |    *  @tparam _CharT  Type of character stream.
 50   |    *  @tparam _Traits  Traits for character type, defaults to
 51   |    *                   char_traits<_CharT>.
 52   |    *
 53   |    *  This is the base class for all output streams.  It provides text
 54   |    *  formatting of all builtin types, and communicates with any class
 55   |    *  derived from basic_streambuf to do the actual output.
 56   |   */
 57   |   template<typename _CharT, typename _Traits>
 58   |     class basic_ostream : virtual public basic_ios<_CharT, _Traits>
 59   |     {
 60   |     public:
 61   |       // Types (inherited from basic_ios):
 62   |       typedef _CharT			 		char_type;
 63   |       typedef typename _Traits::int_type 		int_type;
 64   |       typedef typename _Traits::pos_type 		pos_type;
 65   |       typedef typename _Traits::off_type 		off_type;
 66   |       typedef _Traits			 		traits_type;
 67   | 
 68   |       // Non-standard Types:
 69   |       typedef basic_streambuf<_CharT, _Traits> 		__streambuf_type;
 70   |       typedef basic_ios<_CharT, _Traits>		__ios_type;
 71   |       typedef basic_ostream<_CharT, _Traits>		__ostream_type;
 72   |       typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
 73   |       							__num_put_type;
 74   |       typedef ctype<_CharT>	      			__ctype_type;
 75   | 
 76   |       /**
 77   |        *  @brief  Base constructor.
 78   |        *
 79   |        *  This ctor is almost never called by the user directly, rather from
 80   |        *  derived classes' initialization lists, which pass a pointer to
 81   |        *  their own stream buffer.
 82   |       */
 83   |       explicit
 84   |       basic_ostream(__streambuf_type* __sb)
 85   |       { this->init(__sb); }
 86   | 
 87   |       /**
 88   |        *  @brief  Base destructor.
 89   |        *
 90   |        *  This does very little apart from providing a virtual base dtor.
 91   |       */
 92   |       virtual
 93   |       ~basic_ostream() { }
 94   | 
 95   |       /// Safe prefix/suffix operations.
 96   |       class sentry;
 97   |       friend class sentry;
 98   | 
 99   |       ///@{
100   |       /**
101   |        *  @brief  Interface for manipulators.
102   |        *
103   |        *  Manipulators such as @c std::endl and @c std::hex use these
104   |        *  functions in constructs like "std::cout << std::endl".  For more
105   |        *  information, see the iomanip header.
106   |       */
107   |       __ostream_type&
108   |       operator<<(__ostream_type& (*__pf)(__ostream_type&))
109   |       {
110   | 	// _GLIBCXX_RESOLVE_LIB_DEFECTS
111   | 	// DR 60. What is a formatted input function?
112   | 	// The inserters for manipulators are *not* formatted output functions.
113 I | 	return __pf(*this);
114   |       }
115   | 
116   |       __ostream_type&
117   |       operator<<(__ios_type& (*__pf)(__ios_type&))
118   |       {
119   | 	// _GLIBCXX_RESOLVE_LIB_DEFECTS
120   | 	// DR 60. What is a formatted input function?
121   | 	// The inserters for manipulators are *not* formatted output functions.
122   | 	__pf(*this);
123   | 	return *this;
124   |       }
125   | 
126   |       __ostream_type&
127   |       operator<<(ios_base& (*__pf) (ios_base&))
128   |       {
129   | 	// _GLIBCXX_RESOLVE_LIB_DEFECTS
130   | 	// DR 60. What is a formatted input function?
131   | 	// The inserters for manipulators are *not* formatted output functions.
132   | 	__pf(*this);
133   | 	return *this;
134   |       }
135   |       ///@}
136   | 
137   |       ///@{
138   |       /**
139   |        *  @name Inserters
140   |        *
141   |        *  All the @c operator<< functions (aka <em>formatted output
142   |        *  functions</em>) have some common behavior.  Each starts by
143   |        *  constructing a temporary object of type std::basic_ostream::sentry.
144   |        *  This can have several effects, concluding with the setting of a
145   |        *  status flag; see the sentry documentation for more.
146   |        *
147   |        *  If the sentry status is good, the function tries to generate
148   |        *  whatever data is appropriate for the type of the argument.
149   |        *
150   |        *  If an exception is thrown during insertion, ios_base::badbit
151   |        *  will be turned on in the stream's error state without causing an
152   |        *  ios_base::failure to be thrown.  The original exception will then
153   |        *  be rethrown.
154   |       */
155   | 
156   |       ///@{
157   |       /**
158   |        *  @brief Integer arithmetic inserters
159   |        *  @param  __n A variable of builtin integral type.
160   |        *  @return  @c *this if successful
161   |        *
162   |        *  These functions use the stream's current locale (specifically, the
163   |        *  @c num_get facet) to perform numeric formatting.
164   |       */
165   |       __ostream_type&
166   |       operator<<(long __n)
167   |       { return _M_insert(__n); }
168   | 
169   |       __ostream_type&
170   |       operator<<(unsigned long __n)
171   |       { return _M_insert(__n); }
172   | 
173   |       __ostream_type&
174   |       operator<<(bool __n)
175   |       { return _M_insert(__n); }
176   | 
177   |       __ostream_type&
178   |       operator<<(short __n);
179   | 
180   |       __ostream_type&
181   |       operator<<(unsigned short __n)
182   |       {
183   | 	// _GLIBCXX_RESOLVE_LIB_DEFECTS
184   | 	// 117. basic_ostream uses nonexistent num_put member functions.
185   | 	return _M_insert(static_cast<unsigned long>(__n));
186   |       }
187   | 
188   |       __ostream_type&
189   |       operator<<(int __n);
190   | 
191   |       __ostream_type&
192   |       operator<<(unsigned int __n)
193   |       {
194   | 	// _GLIBCXX_RESOLVE_LIB_DEFECTS
195   | 	// 117. basic_ostream uses nonexistent num_put member functions.
196   | 	return _M_insert(static_cast<unsigned long>(__n));
197   |       }
198   | 
199   | #ifdef _GLIBCXX_USE_LONG_LONG
200   |       __ostream_type&
201   |       operator<<(long long __n)
202   |       { return _M_insert(__n); }
203   | 
204   |       __ostream_type&
205   |       operator<<(unsigned long long __n)
206   |       { return _M_insert(__n); }
207   | #endif
208   |       ///@}
209   | 
210   |       ///@{
211   |       /**
212   |        *  @brief  Floating point arithmetic inserters
213   |        *  @param  __f A variable of builtin floating point type.
214   |        *  @return  @c *this if successful
215   |        *
216   |        *  These functions use the stream's current locale (specifically, the
217   |        *  @c num_get facet) to perform numeric formatting.
218   |       */
219   |       __ostream_type&
220   |       operator<<(double __f)
221   |       { return _M_insert(__f); }
222   | 
223   |       __ostream_type&
224   |       operator<<(float __f)
225   |       {
226   | 	// _GLIBCXX_RESOLVE_LIB_DEFECTS
227   | 	// 117. basic_ostream uses nonexistent num_put member functions.
228   | 	return _M_insert(static_cast<double>(__f));
229   |       }
230   | 
231   |       __ostream_type&
232   |       operator<<(long double __f)
233   |       { return _M_insert(__f); }
234   |       ///@}
235   | 
236   |       /**
237   |        *  @brief  Pointer arithmetic inserters
238   |        *  @param  __p A variable of pointer type.
239   |        *  @return  @c *this if successful
240   |        *
241   |        *  These functions use the stream's current locale (specifically, the
242   |        *  @c num_get facet) to perform numeric formatting.
243   |       */
244   |       __ostream_type&
245   |       operator<<(const void* __p)
246   |       { return _M_insert(__p); }
247   | 
248   | #if __cplusplus >= 201703L
249   |       __ostream_type&
250   |       operator<<(nullptr_t)
251   |       { return *this << "nullptr"; }
252   | #endif
253   | 
254   |       /**
255   |        *  @brief  Extracting from another streambuf.
256   |        *  @param  __sb  A pointer to a streambuf
257   |        *
258   |        *  This function behaves like one of the basic arithmetic extractors,
259   |        *  in that it also constructs a sentry object and has the same error
260   |        *  handling behavior.
261   |        *
262   |        *  If @p __sb is NULL, the stream will set failbit in its error state.
263   |        *
264   |        *  Characters are extracted from @p __sb and inserted into @c *this
265   |        *  until one of the following occurs:
266   |        *
267   |        *  - the input stream reaches end-of-file,
268   |        *  - insertion into the output sequence fails (in this case, the
269   |        *    character that would have been inserted is not extracted), or
270   |        *  - an exception occurs while getting a character from @p __sb, which
271   |        *    sets failbit in the error state
272   |        *
273   |        *  If the function inserts no characters, failbit is set.
274   |       */
275   |       __ostream_type&
276   |       operator<<(__streambuf_type* __sb);
277   |       ///@}
278   | 
279   |       ///@{
280   |       /**
281   |        *  @name Unformatted Output Functions
282   |        *
283   |        *  All the unformatted output functions have some common behavior.
284   |        *  Each starts by constructing a temporary object of type
285   |        *  std::basic_ostream::sentry.  This has several effects, concluding
286   |        *  with the setting of a status flag; see the sentry documentation
287   |        *  for more.
288   |        *
289   |        *  If the sentry status is good, the function tries to generate
290   |        *  whatever data is appropriate for the type of the argument.
291   |        *
292   |        *  If an exception is thrown during insertion, ios_base::badbit
293   |        *  will be turned on in the stream's error state.  If badbit is on in
294   |        *  the stream's exceptions mask, the exception will be rethrown
295   |        *  without completing its actions.
296   |       */
297   | 
298   |       /**
299   |        *  @brief  Simple insertion.
300   |        *  @param  __c  The character to insert.
301   |        *  @return  *this
302   |        *
303   |        *  Tries to insert @p __c.
304   |        *
305   |        *  @note  This function is not overloaded on signed char and
306   |        *         unsigned char.
307   |       */
308   |       __ostream_type&
309   |       put(char_type __c);
310   | 
311   |       /**
312   |        *  @brief  Core write functionality, without sentry.
313   |        *  @param  __s  The array to insert.
314   |        *  @param  __n  Maximum number of characters to insert.
315   |       */
316   |       void
317   |       _M_write(const char_type* __s, streamsize __n)
318   |       {
319   | 	const streamsize __put = this->rdbuf()->sputn(__s, __n);
320   | 	if (__put != __n)
321   | 	  this->setstate(ios_base::badbit);
322   |       }
323   | 
324   |       /**
325   |        *  @brief  Character string insertion.
326   |        *  @param  __s  The array to insert.
327   |        *  @param  __n  Maximum number of characters to insert.
328   |        *  @return  *this
329   |        *
330   |        *  Characters are copied from @p __s and inserted into the stream until
331   |        *  one of the following happens:
332   |        *
333   |        *  - @p __n characters are inserted
334   |        *  - inserting into the output sequence fails (in this case, badbit
335   |        *    will be set in the stream's error state)
336   |        *
337   |        *  @note  This function is not overloaded on signed char and
338   |        *         unsigned char.
339   |       */
340   |       __ostream_type&
341   |       write(const char_type* __s, streamsize __n);
342   |       ///@}
343   | 
344   |       /**
345   |        *  @brief  Synchronizing the stream buffer.
346   |        *  @return  *this
347   |        *
348   |        *  If @c rdbuf() is a null pointer, changes nothing.
349   |        *
350   |        *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,
351   |        *  sets badbit.
352   |       */
353   |       __ostream_type&
354   |       flush();
355   | 
356   |       /**
357   |        *  @brief  Getting the current write position.
358   |        *  @return  A file position object.
359   |        *
360   |        *  If @c fail() is not false, returns @c pos_type(-1) to indicate
361   |        *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,out).
362   |       */
363   |       pos_type
364   |       tellp();
365   | 
366   |       /**
367   |        *  @brief  Changing the current write position.
368   |        *  @param  __pos  A file position object.
369   |        *  @return  *this
370   |        *
371   |        *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(pos).  If
372   |        *  that function fails, sets failbit.
373   |       */
374   |       __ostream_type&
375   |       seekp(pos_type);
376   | 
377   |       /**
378   |        *  @brief  Changing the current write position.
379   |        *  @param  __off  A file offset object.
380   |        *  @param  __dir  The direction in which to seek.
381   |        *  @return  *this
382   |        *
383   |        *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(off,dir).
384   |        *  If that function fails, sets failbit.
385   |       */
386   |        __ostream_type&
387   |       seekp(off_type, ios_base::seekdir);
388   | 
389   |     protected:
390   |       basic_ostream()
391   |       { this->init(0); }
392   | 
393   | #if __cplusplus >= 201103L
394   |       // Non-standard constructor that does not call init()
395   |       basic_ostream(basic_iostream<_CharT, _Traits>&) { }
396   | 
397   |       basic_ostream(const basic_ostream&) = delete;
398   | 
399   |       basic_ostream(basic_ostream&& __rhs)
400   |       : __ios_type()
401   |       { __ios_type::move(__rhs); }
402   | 
403   |       // 27.7.3.3 Assign/swap
404   | 
405   |       basic_ostream& operator=(const basic_ostream&) = delete;
406   | 
407   |       basic_ostream&
408   |       operator=(basic_ostream&& __rhs)
409   |       {
410   | 	swap(__rhs);
411   | 	return *this;
412   |       }
413   | 
414   |       void
415   |       swap(basic_ostream& __rhs)
416   |       { __ios_type::swap(__rhs); }
417   | #endif
418   | 
419   |       template<typename _ValueT>
420   | 	__ostream_type&
421   | 	_M_insert(_ValueT __v);
422   |     };
423   | 
424   |   /**
425   |    *  @brief  Performs setup work for output streams.
426   |    *
427   |    *  Objects of this class are created before all of the standard
428   |    *  inserters are run.  It is responsible for <em>exception-safe prefix and
429   |    *  suffix operations</em>.
430   |   */
431   |   template <typename _CharT, typename _Traits>
432   |     class basic_ostream<_CharT, _Traits>::sentry
433   |     {
434   |       // Data Members.
435   |       bool 				_M_ok;
436   |       basic_ostream<_CharT, _Traits>& 	_M_os;
437   | 
438   |     public:
439   |       /**
440   |        *  @brief  The constructor performs preparatory work.
441   |        *  @param  __os  The output stream to guard.
442   |        *
443   |        *  If the stream state is good (@a __os.good() is true), then if the
444   |        *  stream is tied to another output stream, @c is.tie()->flush()
445   |        *  is called to synchronize the output sequences.
446   |        *
447   |        *  If the stream state is still good, then the sentry state becomes
448   |        *  true (@a okay).
449   |       */
450   |       explicit
451   |       sentry(basic_ostream<_CharT, _Traits>& __os);
452   | 
453   | #pragma GCC diagnostic push
454   | #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
455   |       /**
456   |        *  @brief  Possibly flushes the stream.
457   |        *
458   |        *  If @c ios_base::unitbuf is set in @c os.flags(), and
459   |        *  @c std::uncaught_exception() is true, the sentry destructor calls
460   |        *  @c flush() on the output stream.
461   |       */
462   |       ~sentry()
463   |       {
464   | 	// XXX MT
465   | 	if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
466   | 	  {
467   | 	    // Can't call flush directly or else will get into recursive lock.
468   | 	    if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
469   | 	      _M_os.setstate(ios_base::badbit);
470   | 	  }
471   |       }
472   | #pragma GCC diagnostic pop
473   | 
474   |       /**
475   |        *  @brief  Quick status checking.
476   |        *  @return  The sentry state.
477   |        *
478   |        *  For ease of use, sentries may be converted to booleans.  The
479   |        *  return value is that of the sentry state (true == okay).
480   |       */
481   | #if __cplusplus >= 201103L
482   |       explicit
483   | #endif
484   |       operator bool() const
485   |       { return _M_ok; }
486   |     };
487   | 
488   |   ///@{
489   |   /**
490   |    *  @brief  Character inserters
491   |    *  @param  __out  An output stream.
492   |    *  @param  __c  A character.
493   |    *  @return  out
494   |    *
495   |    *  Behaves like one of the formatted arithmetic inserters described in
496   |    *  std::basic_ostream.  After constructing a sentry object with good
497   |    *  status, this function inserts a single character and any required
498   |    *  padding (as determined by [22.2.2.2.2]).  @c __out.width(0) is then
499   |    *  called.
500   |    *
501   |    *  If @p __c is of type @c char and the character type of the stream is not
502   |    *  @c char, the character is widened before insertion.
503   |   */
504   |   template<typename _CharT, typename _Traits>
505   |     inline basic_ostream<_CharT, _Traits>&
506   |     operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
507   |     { return __ostream_insert(__out, &__c, 1); }
508   | 
509   |   template<typename _CharT, typename _Traits>
510   |     inline basic_ostream<_CharT, _Traits>&
511   |     operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
512   |     { return (__out << __out.widen(__c)); }
513   | 
514   |   // Specialization
515   |   template<typename _Traits>
516   |     inline basic_ostream<char, _Traits>&
517   |     operator<<(basic_ostream<char, _Traits>& __out, char __c)
518   |     { return __ostream_insert(__out, &__c, 1); }
519   | 
520   |   // Signed and unsigned
521   |   template<typename _Traits>
522   |     inline basic_ostream<char, _Traits>&
523   |     operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
524   |     { return (__out << static_cast<char>(__c)); }
525   | 
526   |   template<typename _Traits>
527   |     inline basic_ostream<char, _Traits>&
528   |     operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
529   |     { return (__out << static_cast<char>(__c)); }
530   | 
531   | #if __cplusplus > 201703L
532   |   // The following deleted overloads prevent formatting character values as
533   |   // numeric values.
534   | 
535   | #ifdef _GLIBCXX_USE_WCHAR_T
536   |   template<typename _Traits>
537   |     basic_ostream<char, _Traits>&
538   |     operator<<(basic_ostream<char, _Traits>&, wchar_t) = delete;
539   | #endif // _GLIBCXX_USE_WCHAR_T
540   | 
541   | #ifdef _GLIBCXX_USE_CHAR8_T
542   |   template<typename _Traits>
543   |     basic_ostream<char, _Traits>&
544   |     operator<<(basic_ostream<char, _Traits>&, char8_t) = delete;
545   | #endif
546   | 
547   |   template<typename _Traits>
548   |     basic_ostream<char, _Traits>&
549   |     operator<<(basic_ostream<char, _Traits>&, char16_t) = delete;
550   | 
551   |   template<typename _Traits>
552   |     basic_ostream<char, _Traits>&
553   |     operator<<(basic_ostream<char, _Traits>&, char32_t) = delete;
554   | 
555   | #ifdef _GLIBCXX_USE_WCHAR_T
556   | #ifdef _GLIBCXX_USE_CHAR8_T
557   |   template<typename _Traits>
558   |     basic_ostream<wchar_t, _Traits>&
559   |     operator<<(basic_ostream<wchar_t, _Traits>&, char8_t) = delete;
560   | #endif // _GLIBCXX_USE_CHAR8_T
561   | 
562   |   template<typename _Traits>
563   |     basic_ostream<wchar_t, _Traits>&
564   |     operator<<(basic_ostream<wchar_t, _Traits>&, char16_t) = delete;
565   | 
566   |   template<typename _Traits>
567   |     basic_ostream<wchar_t, _Traits>&
568   |     operator<<(basic_ostream<wchar_t, _Traits>&, char32_t) = delete;
569   | #endif // _GLIBCXX_USE_WCHAR_T
570   | #endif // C++20
571   |   ///@}
572   | 
573   |   ///@{
574   |   /**
575   |    *  @brief  String inserters
576   |    *  @param  __out  An output stream.
577   |    *  @param  __s  A character string.
578   |    *  @return  out
579   |    *  @pre  @p __s must be a non-NULL pointer
580   |    *
581   |    *  Behaves like one of the formatted arithmetic inserters described in
582   |    *  std::basic_ostream.  After constructing a sentry object with good
583   |    *  status, this function inserts @c traits::length(__s) characters starting
584   |    *  at @p __s, widened if necessary, followed by any required padding (as
585   |    *  determined by [22.2.2.2.2]).  @c __out.width(0) is then called.
586   |   */
587   |   template<typename _CharT, typename _Traits>
588   |     inline basic_ostream<_CharT, _Traits>&
589   |     operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
590   |     {
591   |       if (!__s)
592   | 	__out.setstate(ios_base::badbit);
593   |       else
594   | 	__ostream_insert(__out, __s,
595   | 			 static_cast<streamsize>(_Traits::length(__s)));
596   |       return __out;
597   |     }
598   | 
599   |   template<typename _CharT, typename _Traits>
600   |     basic_ostream<_CharT, _Traits> &
601   |     operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);
602   | 
603   |   // Partial specializations
604   |   template<typename _Traits>
605   |     inline basic_ostream<char, _Traits>&
606   |     operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
607   |     {
608   |       if (!__s)
609 I | 	__out.setstate(ios_base::badbit);
610   |       else
611   | 	__ostream_insert(__out, __s,
612 I | 			 static_cast<streamsize>(_Traits::length(__s)));
613   |       return __out;
614   |     }
615   | 
616   |   // Signed and unsigned
617   |   template<typename _Traits>
618   |     inline basic_ostream<char, _Traits>&
619   |     operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
620   |     { return (__out << reinterpret_cast<const char*>(__s)); }
621   | 
622   |   template<typename _Traits>
623   |     inline basic_ostream<char, _Traits> &
624   |     operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
625   |     { return (__out << reinterpret_cast<const char*>(__s)); }
626   | 
627   | #if __cplusplus > 201703L
628   |    // The following deleted overloads prevent formatting strings as
629   |    // pointer values.
630   | 
631   | #ifdef _GLIBCXX_USE_WCHAR_T
632   |   template<typename _Traits>
633   |     basic_ostream<char, _Traits>&
634   |     operator<<(basic_ostream<char, _Traits>&, const wchar_t*) = delete;
635   | #endif // _GLIBCXX_USE_WCHAR_T
636   | 
637   | #ifdef _GLIBCXX_USE_CHAR8_T
638   |   template<typename _Traits>
639   |     basic_ostream<char, _Traits>&
640   |     operator<<(basic_ostream<char, _Traits>&, const char8_t*) = delete;
641   | #endif // _GLIBCXX_USE_CHAR8_T
642   | 
643   |   template<typename _Traits>
644   |     basic_ostream<char, _Traits>&
645   |     operator<<(basic_ostream<char, _Traits>&, const char16_t*) = delete;
646   | 
647   |   template<typename _Traits>
648   |     basic_ostream<char, _Traits>&
649   |     operator<<(basic_ostream<char, _Traits>&, const char32_t*) = delete;
650   | 
651   | #ifdef _GLIBCXX_USE_WCHAR_T
652   | #ifdef _GLIBCXX_USE_CHAR8_T
653   |   template<typename _Traits>
654   |     basic_ostream<wchar_t, _Traits>&
655   |     operator<<(basic_ostream<wchar_t, _Traits>&, const char8_t*) = delete;
656   | #endif
657   | 
658   |   template<typename _Traits>
659   |     basic_ostream<wchar_t, _Traits>&
660   |     operator<<(basic_ostream<wchar_t, _Traits>&, const char16_t*) = delete;
661   | 
662   |   template<typename _Traits>
663   |     basic_ostream<wchar_t, _Traits>&
664   |     operator<<(basic_ostream<wchar_t, _Traits>&, const char32_t*) = delete;
665   | #endif // _GLIBCXX_USE_WCHAR_T
666   | #endif // C++20
667   |   ///@}
668   | 
669   |   // Standard basic_ostream manipulators
670   | 
671   |   /**
672   |    *  @brief  Write a newline and flush the stream.
673   |    *
674   |    *  This manipulator is often mistakenly used when a simple newline is
675   |    *  desired, leading to poor buffering performance.  See
676   |    *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html#io.streambuf.buffering
677   |    *  for more on this subject.
678   |   */
679   |   template<typename _CharT, typename _Traits>
680   |     inline basic_ostream<_CharT, _Traits>&
681   |     endl(basic_ostream<_CharT, _Traits>& __os)
682   |     { return flush(__os.put(__os.widen('\n'))); }
    I |              ^
    I |                                  ^
683   | 
684   |   /**
685   |    *  @brief  Write a null character into the output sequence.
686   |    *
687   |    *  <em>Null character</em> is @c CharT() by definition.  For CharT
688   |    *  of @c char, this correctly writes the ASCII @c NUL character
689   |    *  string terminator.
690   |   */
691   |   template<typename _CharT, typename _Traits>
692   |     inline basic_ostream<_CharT, _Traits>&
693   |     ends(basic_ostream<_CharT, _Traits>& __os)
694   |     { return __os.put(_CharT()); }
695   | 
696   |   /**
697   |    *  @brief  Flushes the output stream.
698   |    *
699   |    *  This manipulator simply calls the stream's @c flush() member function.
700   |   */
701   |   template<typename _CharT, typename _Traits>
702   |     inline basic_ostream<_CharT, _Traits>&
703   |     flush(basic_ostream<_CharT, _Traits>& __os)
704   |     { return __os.flush(); }
705   | 
706   | #if __cplusplus >= 201103L
707   |   // C++11 27.7.3.9 Rvalue stream insertion [ostream.rvalue]
708   |   // _GLIBCXX_RESOLVE_LIB_DEFECTS
709   |   // 1203. More useful rvalue stream insertion
710   | 
711   | #if __cpp_lib_concepts
712   |   // Use concepts if possible because they're cheaper to evaluate.
713   |   template<typename _Tp>
714   |     concept __derived_from_ios_base = is_class_v<_Tp>
715   |       && (!is_same_v<_Tp, ios_base>)
716   |       && requires (_Tp* __t, ios_base* __b) { __b = __t; };
717   | 
718   |   template<typename _Os, typename _Tp>
719   |     requires __derived_from_ios_base<_Os>
720   |       && requires (_Os& __os, const _Tp& __t) { __os << __t; }
721   |     using __rvalue_stream_insertion_t = _Os&&;
722   | #else
723   |   template<typename _Tp>
724   |     using _Require_derived_from_ios_base
725   |       = _Require<is_class<_Tp>, __not_<is_same<_Tp, ios_base>>,
726   | 		 is_convertible<typename add_pointer<_Tp>::type, ios_base*>>;
727   | 
728   |   template<typename _Os, typename _Tp,
729   | 	   typename = _Require_derived_from_ios_base<_Os>,
730   | 	   typename
731   | 	     = decltype(std::declval<_Os&>() << std::declval<const _Tp&>())>
732   |     using __rvalue_stream_insertion_t = _Os&&;
733   | #endif
734   | 
735   |   /**
736   |    *  @brief  Generic inserter for rvalue stream
737   |    *  @param  __os  An input stream.
738   |    *  @param  __x  A reference to the object being inserted.
739   |    *  @return  __os
740   |    *
741   |    *  This is just a forwarding function to allow insertion to
742   |    *  rvalue streams since they won't bind to the inserter functions
743   |    *  that take an lvalue reference.
744   |   */
745   |   template<typename _Ostream, typename _Tp>
746   |     inline __rvalue_stream_insertion_t<_Ostream, _Tp>
747   |     operator<<(_Ostream&& __os, const _Tp& __x)
748   |     {
749   |       __os << __x;
750   |       return std::move(__os);
751   |     }
752   | 
753   | #if __cplusplus > 201703L && _GLIBCXX_USE_CXX11_ABI
754   |   template<typename _CharT, typename _Traits>
755   |     class __syncbuf_base : public basic_streambuf<_CharT, _Traits>
756   |     {
757   |     public:
758   |       static bool*
759   |       _S_get(basic_streambuf<_CharT, _Traits>* __buf [[maybe_unused]]) noexcept
760   |       {
761   | #if __cpp_rtti
762   | 	if (auto __p = dynamic_cast<__syncbuf_base*>(__buf))
763   | 	  return &__p->_M_emit_on_sync;
764   | #endif
765   | 	return nullptr;
766   |       }
767   | 
768   |     protected:
769   |       __syncbuf_base(basic_streambuf<_CharT, _Traits>* __w = nullptr)
770   |       : _M_wrapped(__w)
771   |       { }
772   | 
773   |       basic_streambuf<_CharT, _Traits>* _M_wrapped = nullptr;
774   |       bool _M_emit_on_sync = false;
775   |       bool _M_needs_sync = false;
776   |     };
777   | 
778   |   template<typename _CharT, typename _Traits>
779   |     inline basic_ostream<_CharT, _Traits>&
780   |     emit_on_flush(basic_ostream<_CharT, _Traits>& __os)
781   |     {
782   |       if (bool* __flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf()))
783   | 	*__flag = true;
784   |       return __os;
785   |     }
786   | 
787   |   template<typename _CharT, typename _Traits>
788   |     inline basic_ostream<_CharT, _Traits>&
789   |     noemit_on_flush(basic_ostream<_CharT, _Traits>& __os)
790   |     {
791   |       if (bool* __flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf()))
792   | 	*__flag = false;
793   |       return __os;
794   |     }
795   | 
796   |   template<typename _CharT, typename _Traits>
797   |     inline basic_ostream<_CharT, _Traits>&
798   |     flush_emit(basic_ostream<_CharT, _Traits>& __os)
799   |     {
800   |       struct _Restore
801   |       {
802   | 	~_Restore() { *_M_flag = _M_prev; }
803   | 
804   | 	bool _M_prev = false;
805   | 	bool* _M_flag = &_M_prev;
806   |       } __restore;
807   | 
808   |       if (bool* __flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf()))
809   | 	{
810   | 	  __restore._M_prev = *__flag;
811   | 	  __restore._M_flag = __flag;
812   | 	  *__flag = true;
813   | 	}
814   | 
815   |       __os.flush();
816   |       return __os;
817   |     }
818   | 
819   | #endif // C++20
820   | 
821   | #endif // C++11
822   | 
823   | _GLIBCXX_END_NAMESPACE_VERSION
824   | } // namespace std
825   | 
826   | #include <bits/ostream.tcc>
827   | 
828   | #endif	/* _GLIBCXX_OSTREAM */

< prog.cpp
  1   | 
  2   | #include <iostream>
  3   | #include <string>
  4   | using namespace std;
  5   | 
  6   | int main() {
  7   |   long W = 0;
  8   |   long X = 0;
  9   |   long Y = 0;
 10   |   long Z = 0;
 11   | 
 12   |   int inputs[14] = {};
 13 I | 	cin >> W;
 14   | 	X = X * 0;
 15   | 	X = X + Z;
 16   | 	X = X % 26;
 17   | 	Z = Z / 1;
 18   | 	X = X + 10;
 19   | 	X = X == W;
 20   | 	X = X == 0;
 21   | 	Y = Y * 0;
 22   | 	Y = Y + 25;
 23   | 	Y = Y * X;
 24   | 	Y = Y + 1;
 25   | 	Z = Z * Y;
 26   | 	Y = Y * 0;
 27   | 	Y = Y + W;
 28   | 	Y = Y + 10;
 29   | 	Y = Y * X;
 30   | 	Z = Z + Y;
 31 I | 	cin >> W;
 32   | 	X = X * 0;
 33   | 	X = X + Z;
 34   | 	X = X % 26;
 35   | 	Z = Z / 1;
 36   | 	X = X + 13;
 37   | 	X = X == W;
 38   | 	X = X == 0;
 39   | 	Y = Y * 0;
 40   | 	Y = Y + 25;
 41   | 	Y = Y * X;
 42   | 	Y = Y + 1;
 43   | 	Z = Z * Y;
 44   | 	Y = Y * 0;
 45   | 	Y = Y + W;
 46   | 	Y = Y + 5;
 47   | 	Y = Y * X;
 48   | 	Z = Z + Y;
 49 I | 	cin >> W;
 50   | 	X = X * 0;
 51   | 	X = X + Z;
 52   | 	X = X % 26;
 53   | 	Z = Z / 1;
 54   | 	X = X + 15;
 55   | 	X = X == W;
 56   | 	X = X == 0;
 57   | 	Y = Y * 0;
 58   | 	Y = Y + 25;
 59   | 	Y = Y * X;
 60   | 	Y = Y + 1;
 61   | 	Z = Z * Y;
 62   | 	Y = Y * 0;
 63   | 	Y = Y + W;
 64   | 	Y = Y + 12;
 65   | 	Y = Y * X;
 66   | 	Z = Z + Y;
 67 I | 	cin >> W;
 68   | 	X = X * 0;
 69   | 	X = X + Z;
 70   | 	X = X % 26;
 71   | 	Z = Z / 26;
 72   | 	X = X + -12;
 73   | 	X = X == W;
 74   | 	X = X == 0;
 75   | 	Y = Y * 0;
 76   | 	Y = Y + 25;
 77   | 	Y = Y * X;
 78   | 	Y = Y + 1;
 79   | 	Z = Z * Y;
 80   | 	Y = Y * 0;
 81   | 	Y = Y + W;
 82   | 	Y = Y + 12;
 83   | 	Y = Y * X;
 84   | 	Z = Z + Y;
 85 I | 	cin >> W;
 86   | 	X = X * 0;
 87   | 	X = X + Z;
 88   | 	X = X % 26;
 89   | 	Z = Z / 1;
 90   | 	X = X + 14;
 91   | 	X = X == W;
 92   | 	X = X == 0;
 93   | 	Y = Y * 0;
 94   | 	Y = Y + 25;
 95   | 	Y = Y * X;
 96   | 	Y = Y + 1;
 97   | 	Z = Z * Y;
 98   | 	Y = Y * 0;
 99   | 	Y = Y + W;
100   | 	Y = Y + 6;
101   | 	Y = Y * X;
102   | 	Z = Z + Y;
103 I | 	cin >> W;
104   | 	X = X * 0;
105   | 	X = X + Z;
106   | 	X = X % 26;
107   | 	Z = Z / 26;
108   | 	X = X + -2;
109   | 	X = X == W;
110   | 	X = X == 0;
111   | 	Y = Y * 0;
112   | 	Y = Y + 25;
113   | 	Y = Y * X;
114   | 	Y = Y + 1;
115   | 	Z = Z * Y;
116   | 	Y = Y * 0;
117   | 	Y = Y + W;
118   | 	Y = Y + 4;
119   | 	Y = Y * X;
120   | 	Z = Z + Y;
121 I | 	cin >> W;
122   | 	X = X * 0;
123   | 	X = X + Z;
124   | 	X = X % 26;
125   | 	Z = Z / 1;
126   | 	X = X + 13;
127   | 	X = X == W;
128   | 	X = X == 0;
129   | 	Y = Y * 0;
130   | 	Y = Y + 25;
131   | 	Y = Y * X;
132   | 	Y = Y + 1;
133   | 	Z = Z * Y;
134   | 	Y = Y * 0;
135   | 	Y = Y + W;
136   | 	Y = Y + 15;
137   | 	Y = Y * X;
138   | 	Z = Z + Y;
139 I | 	cin >> W;
140   | 	X = X * 0;
141   | 	X = X + Z;
142   | 	X = X % 26;
143   | 	Z = Z / 26;
144   | 	X = X + -12;
145   | 	X = X == W;
146   | 	X = X == 0;
147   | 	Y = Y * 0;
148   | 	Y = Y + 25;
149   | 	Y = Y * X;
150   | 	Y = Y + 1;
151   | 	Z = Z * Y;
152   | 	Y = Y * 0;
153   | 	Y = Y + W;
154   | 	Y = Y + 3;
155   | 	Y = Y * X;
156   | 	Z = Z + Y;
157 I | 	cin >> W;
158   | 	X = X * 0;
159   | 	X = X + Z;
160   | 	X = X % 26;
161   | 	Z = Z / 1;
162   | 	X = X + 15;
163   | 	X = X == W;
164   | 	X = X == 0;
165   | 	Y = Y * 0;
166   | 	Y = Y + 25;
167   | 	Y = Y * X;
168   | 	Y = Y + 1;
169   | 	Z = Z * Y;
170   | 	Y = Y * 0;
171   | 	Y = Y + W;
172   | 	Y = Y + 7;
173   | 	Y = Y * X;
174   | 	Z = Z + Y;
175 I | 	cin >> W;
176   | 	X = X * 0;
177   | 	X = X + Z;
178   | 	X = X % 26;
179   | 	Z = Z / 1;
180   | 	X = X + 11;
181   | 	X = X == W;
182   | 	X = X == 0;
183   | 	Y = Y * 0;
184   | 	Y = Y + 25;
185   | 	Y = Y * X;
186   | 	Y = Y + 1;
187   | 	Z = Z * Y;
188   | 	Y = Y * 0;
189   | 	Y = Y + W;
190   | 	Y = Y + 11;
191   | 	Y = Y * X;
192   | 	Z = Z + Y;
193 I | 	cin >> W;
194   | 	X = X * 0;
195   | 	X = X + Z;
196   | 	X = X % 26;
197   | 	Z = Z / 26;
198   | 	X = X + -3;
199   | 	X = X == W;
200   | 	X = X == 0;
201   | 	Y = Y * 0;
202   | 	Y = Y + 25;
203   | 	Y = Y * X;
204   | 	Y = Y + 1;
205   | 	Z = Z * Y;
206   | 	Y = Y * 0;
207   | 	Y = Y + W;
208   | 	Y = Y + 2;
209   | 	Y = Y * X;
210   | 	Z = Z + Y;
211 I | 	cin >> W;
212   | 	X = X * 0;
213   | 	X = X + Z;
214   | 	X = X % 26;
215   | 	Z = Z / 26;
216   | 	X = X + -13;
217   | 	X = X == W;
218   | 	X = X == 0;
219   | 	Y = Y * 0;
220   | 	Y = Y + 25;
221   | 	Y = Y * X;
222   | 	Y = Y + 1;
223   | 	Z = Z * Y;
224   | 	Y = Y * 0;
225   | 	Y = Y + W;
226   | 	Y = Y + 12;
227   | 	Y = Y * X;
228   | 	Z = Z + Y;
229 I | 	cin >> W;
230   | 	X = X * 0;
231   | 	X = X + Z;
232   | 	X = X % 26;
233   | 	Z = Z / 26;
234   | 	X = X + -12;
235   | 	X = X == W;
236   | 	X = X == 0;
237   | 	Y = Y * 0;
238   | 	Y = Y + 25;
239   | 	Y = Y * X;
240   | 	Y = Y + 1;
241   | 	Z = Z * Y;
242   | 	Y = Y * 0;
243   | 	Y = Y + W;
244   | 	Y = Y + 4;
245   | 	Y = Y * X;
246   | 	Z = Z + Y;
247 I | 	cin >> W;
248   | 	X = X * 0;
249   | 	X = X + Z;
250   | 	X = X % 26;
251   | 	Z = Z / 26;
252   | 	X = X + -13;
253   | 	X = X == W;
254   | 	X = X == 0;
255   | 	Y = Y * 0;
256   | 	Y = Y + 25;
257   | 	Y = Y * X;
258   | 	Y = Y + 1;
259   | 	Z = Z * Y;
260   | 	Y = Y * 0;
261   | 	Y = Y + W;
262   | 	Y = Y + 11;
263   | 	Y = Y * X;
264   | 	Z = Z + Y;
265   | 
266   |   
267   |   cout << "Finished" << endl;
    I |        ^
    I |                      ^
268   |   cout << "vars=" << W << "," << "," << X << "," << Y << "," << Z << endl;
    I |        ^
    I |                   ^
    I |                        ^
    I |                               ^
    I |                                      ^
    I |                                           ^
    I |                                                  ^
    I |                                                       ^
    I |                                                              ^
    I |                                                                   ^
269   |   return Z == 0;
270   | }
